<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>OASIS Advanced Message Queuing Protocol (AMQP) Version 1.0, Part 2: Transport</title><style type="text/css">
            body {
            margin: 2em;
            padding: 1em;
            font-size: 10.0pt;
            font-family: "DejaVu LGC Sans", "Bitstream Vera Sans", arial, helvetica, sans-serif;
            }
h1
	{margin-top:24.0pt;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:.3in;
	text-indent:-.3in;
	page-break-before:always;
	page-break-after:avoid;
	text-autospace:ideograph-other;
	border:none;
	padding:0in;
	font-size:13.0pt;
	font-family:"Arial","sans-serif";
	color:#3B006F;
	font-weight:bold;}
h2
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.4in;
	margin-bottom:.0001pt;
	text-indent:-.4in;
	page-break-after:avoid;
	text-autospace:ideograph-other;
	font-size:12.0pt;
	font-family:"Arial","sans-serif";
	color:#3B006F;
	font-weight:bold;}
h3
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	text-indent:-.5in;
	page-break-after:avoid;
	text-autospace:ideograph-other;
	font-size:11.0pt;
	font-family:"Arial","sans-serif";
	color:#3B006F;
	font-weight:bold;}
h4
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.6in;
	margin-bottom:.0001pt;
	text-indent:-.6in;
	page-break-after:avoid;
	text-autospace:ideograph-other;
	font-size:10.0pt;
	font-family:"Arial","sans-serif";
	color:#3B006F;
	font-weight:bold;}
h5
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.7in;
	margin-bottom:.0001pt;
	text-indent:-.7in;
	page-break-after:avoid;
	text-autospace:ideograph-other;
	font-size:10.0pt;
	font-family:"Arial","sans-serif";
	color:#3B006F;
	font-weight:bold;}
h6
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.8in;
	margin-bottom:.0001pt;
	text-indent:-.8in;
	page-break-after:avoid;
	text-autospace:ideograph-other;
	font-size:9.0pt;
	font-family:"Arial","sans-serif";
	color:#3B006F;
	font-weight:bold;}
                  
            h1 a, h2 a, h3 a, h4 a {
            color: #3B006F
            }
      
            a {
            text-decoration: none;
            color: #66f;
            }
            
            a.anchor {
            color: #000;
            }
            
            a.toc {
            float: right;
            }
            
            table {
            border-collapse: collapse;
            margin: 1em 1em;
            }
            
            dt {
            font-weight: bold;
            }
            
            dt:after {
            content: ":";
            }
            
            div.toc {
            border: 1px solid #ccc;
            padding: 1em;
            }
            
            table.toc {
            margin: 0;
            }
            
            table.pre {
            background: #eee;
            border: 1px solid #ccc;
            margin-left: auto;
            margin-right: auto;
            }
            
            table.pre td {
            font-family: Courier, monospace;
            font-size:10.0pt;
            white-space: pre;
            padding: 0em 2em;
            }
            
            table.definition {
            width: 100%;
            }
            
            table.signature {
            background: #eee;
            border: 1px solid #ccc;
            width: 100%;
            }
            
            table.signature td {
            font-family: monospace;
            font-size:9.0pt;
            white-space: pre;
            padding: 1em;
            }

            table.encodings th {
            font-size:10.0pt;
            padding: 2px 2em;
            border-bottom-style:solid;
            border-bottom-width:2px;
            text-align:left;
            }

            table.encodings td {
            font-size:10.0pt;
            padding: 2px 2em;
            }
            
            table.constants td {
            font-size:10.0pt;
            padding: 2px 1em;
            }

            table.composite {
            width: 100%;
            }
            
            td.field {
            padding: 0.5em 2em;
            }
            
            div.section {
            padding: 0 0 0 1em;
            }
            
            div.doc {
            padding: 0 0 1em 0;
            }
            
            table.composite div.doc {
            padding: 0;
            }
            
            table.error {
            width: 100%;
            margin: 0;
            }
            
            table.error tr:last-child td {
            padding: 0 0 0 1em;
            }
            
            .todo:before {
            content: "TODO: ";
            font-weight: bold;
            color: red;
            }
            
            .todo {
            font-variant: small-caps;
            font-weight: bold;
            color: red;
            }

p.OasisTitle
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:0in;
	text-autospace:ideograph-other;
	border:none;
	padding:0in;
	font-size:24.0pt;
	font-family:"Arial","sans-serif";
	color:#3B006F;
	font-weight:bold;}

p.OasisContributor
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	text-autospace:ideograph-other;
	font-size:10.0pt;
	font-family:"Arial","sans-serif";}
a:link, span.OasisHyperlink
	{color:#0000EE;
	text-decoration:none;}
a:visited, span.OasisHyperlinkFollowed
	{color:purple;
	text-decoration:underline;}

p.OasisSubtitle
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:0in;
	text-autospace:ideograph-other;
	border:none;
	padding:0in;
	font-size:18.0pt;
	font-family:"Arial","sans-serif";
	color:#3B006F;
	font-weight:bold;}
p.OasisTitlePageInfo
	{margin-top:4.3pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	page-break-after:avoid;
	text-autospace:ideograph-other;
	font-size:10.0pt;
	font-family:"Arial","sans-serif";
	color:#3B006F;
	font-weight:bold;}
p.OasisTitlePageInfoDescription
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:4.3pt;
	margin-left:.5in;
	text-autospace:ideograph-other;
	font-size:10.0pt;
	font-family:"Arial","sans-serif";}

        table.RevisionHistory {
            width: 650px;
            }
        table.RevisionHistory th {
            font-size:11.0pt;
            padding: 2px;
            padding-below: 4px;
            color:#3B006F;
            text-align:left;
            font-weight:bold;}
        table.RevisionHistory td.issue {
            width:6em;
            padding-left: 1em;
            vertical-align: top;
            text-align: right}
</style></head><body><img width="203" height="54" src="oasis.jpg"><hr><p class="OasisTitle">OASIS Advanced Message Queuing Protocol (AMQP) Version 1.0<br>
        Part 2: Transport</p><p class="OasisSubtitle">OASIS Standard</p><p class="OasisSubtitle">29 October 2012</p><p class="OasisTitlePageInfo"><span style="font-size:12.0pt">Specification URIs</span></p><p class="OasisTitlePageInfo">This version:</p><p class="OasisTitlePageInfoDescription" style="margin-bottom:0in;margin-bottom:.0001pt"><a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-transport-v1.0-os.xml">http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-transport-v1.0-os.xml</a> (Authoritative)</p><p class="OasisTitlePageInfoDescription" style="margin-bottom:0in;margin-bottom:.0001pt"><a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-transport-v1.0-os.html">http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-transport-v1.0-os.html</a></p><p class="OasisTitlePageInfoDescription" style="margin-bottom:0in;margin-bottom:.0001pt"><a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-complete-v1.0-os.pdf">http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-complete-v1.0-os.pdf</a></p><p class="OasisTitlePageInfo">Previous version:</p><p class="OasisTitlePageInfoDescription" style="margin-bottom:0in;margin-bottom:.0001pt"><a href="http://docs.oasis-open.org/amqp/core/v1.0/csprd01/amqp-core-transport-v1.0-csprd01.xml">http://docs.oasis-open.org/amqp/core/v1.0/csprd01/amqp-core-transport-v1.0-csprd01.xml</a> (Authoritative)</p><p class="OasisTitlePageInfoDescription" style="margin-bottom:0in;margin-bottom:.0001pt"><a href="http://docs.oasis-open.org/amqp/core/v1.0/csprd01/amqp-core-transport-v1.0-csprd01.html">http://docs.oasis-open.org/amqp/core/v1.0/csprd01/amqp-core-transport-v1.0-csprd01.html</a></p><p class="OasisTitlePageInfoDescription" style="margin-bottom:0in;margin-bottom:.0001pt"><a href="http://docs.oasis-open.org/amqp/core/v1.0/csprd01/amqp-core-complete-v1.0-csprd01.pdf">http://docs.oasis-open.org/amqp/core/v1.0/csprd01/amqp-core-complete-v1.0-csprd01.pdf</a></p><p class="OasisTitlePageInfo">Latest version:</p><p class="OasisTitlePageInfoDescription" style="margin-bottom:0in;margin-bottom:.0001pt"><a href="http://docs.oasis-open.org/amqp/core/v1.0/amqp-core-transport-v1.0.xml">http://docs.oasis-open.org/amqp/core/v1.0/amqp-core-transport-v1.0.xml</a> (Authoritative)</p><p class="OasisTitlePageInfoDescription" style="margin-bottom:0in;margin-bottom:.0001pt"><a href="http://docs.oasis-open.org/amqp/core/v1.0/amqp-core-transport-v1.0.html">http://docs.oasis-open.org/amqp/core/v1.0/amqp-core-transport-v1.0.html</a></p><p class="OasisTitlePageInfoDescription" style="margin-bottom:0in;margin-bottom:.0001pt"><a href="http://docs.oasis-open.org/amqp/core/v1.0/amqp-core-complete-v1.0.pdf">http://docs.oasis-open.org/amqp/core/v1.0/amqp-core-complete-v1.0.pdf</a></p><p class="OasisTitlePageInfo">Technical Committee:</p><p class="OasisTitlePageInfoDescription" style="margin-bottom:0in;margin-bottom:.0001pt"><a href="http://www.oasis-open.org/committees/amqp/">OASIS Advanced Message Queuing Protocol (AMQP) TC</a></p><p class="OasisTitlePageInfo">Chairs:</p>
  <p class="OasisContributor">Ram Jeyaraman (<span class="OasisHyperlink"><a href="mailto:Ram.Jeyaraman@microsoft.com">Ram.Jeyaraman@microsoft.com</a></span>),
<span class="OasisHyperlink"><a href="http://www.microsoft.com">Microsoft</a></span></p>
  <p class="OasisContributor">Angus Telfer (<span class="OasisHyperlink"><a href="mailto:angus.telfer@inetco.com">angus.telfer@inetco.com</a></span>),
<span class="OasisHyperlink"><a href="http://www.inetco.com">INETCO Systems</a></span></p>
<p class="OasisTitlePageInfo">Editors:</p>
  <p class="OasisContributor">Robert Godfrey (<span class="OasisHyperlink"><a href="mailto:robert.godfrey@jpmorgan.com">robert.godfrey@jpmorgan.com</a></span>),
<span class="OasisHyperlink"><a href="http://www.jpmorganchase.com">JPMorgan Chase &amp; Co.</a></span></p>
  <p class="OasisContributor">David Ingham (<span class="OasisHyperlink"><a href="mailto:David.Ingham@microsoft.com">David.Ingham@microsoft.com</a></span>),
<span class="OasisHyperlink"><a href="http://www.microsoft.com">Microsoft</a></span></p>
  <p class="OasisContributor">Rafael Schloming (<span class="OasisHyperlink"><a href="mailto:rafaels@redhat.com">rafaels@redhat.com</a></span>),
<span class="OasisHyperlink"><a href="http://www.redhat.com">Red Hat</a></span></p>
<p class="OasisTitlePageInfo">Additional artifacts:</p><p class="OasisTitlePageInfoDescription" style="margin-bottom:0in;margin-bottom:.0001pt">This specification consists of the following documents:</p><p class="OasisTitlePageInfoDescription" style="margin-bottom:0in;margin-bottom:.0001pt"><span style="font-family:Symbol">·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span><span class="OasisHyperLink"><a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-overview-v1.0-os.html#toc">Part 0: Overview</a></span> - Overview of the AMQP specification</p><p class="OasisTitlePageInfoDescription" style="margin-bottom:0in;margin-bottom:.0001pt"><span style="font-family:Symbol">·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span><span class="OasisHyperLink"><a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#toc">Part 1: Types</a></span> - AMQP type system and encoding</p><p class="OasisTitlePageInfoDescription" style="margin-bottom:0in;margin-bottom:.0001pt"><span style="font-family:Symbol">·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span><span class="OasisHyperLink"><a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-transport-v1.0-os.html#toc">Part 2: Transport</a></span> (this document) - AMQP transport layer</p><p class="OasisTitlePageInfoDescription" style="margin-bottom:0in;margin-bottom:.0001pt"><span style="font-family:Symbol">·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span><span class="OasisHyperLink"><a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#toc">Part 3: Messaging</a></span> - AMQP Messaging Layer</p><p class="OasisTitlePageInfoDescription" style="margin-bottom:0in;margin-bottom:.0001pt"><span style="font-family:Symbol">·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span><span class="OasisHyperLink"><a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-transactions-v1.0-os.html#toc">Part 4: Transactions</a></span> - AMQP Transactions Layer</p><p class="OasisTitlePageInfoDescription" style="margin-bottom:0in;margin-bottom:.0001pt"><span style="font-family:Symbol">·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span><span class="OasisHyperLink"><a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-security-v1.0-os.html#toc">Part 5: Security</a></span> - AMQP Security Layers</p><p class="OasisTitlePageInfoDescription" style="margin-bottom:0in;margin-bottom:.0001pt"><span style="font-family:Symbol">·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span><span class="OasisHyperLink"><a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp.dtd">XML Document Type Definition (DTD)</a></span></p><p class="OasisTitlePageInfo">Related work:</p><p class="OasisTitlePageInfoDescription" style="margin-bottom:0in;margin-bottom:.0001pt">This specification replaces or supersedes:</p><p class="OasisTitlePageInfoDescription" style="margin-bottom:0in;margin-bottom:.0001pt"><span style="font-family:Symbol">·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span>AMQP v1.0 Final, 07 October 2011. <span class="OasisHyperLink"><a href="http://www.amqp.org/specification/1.0/amqp-org-download">http://www.amqp.org/specification/1.0/amqp-org-download</a></span></p><p class="OasisTitlePageInfo">Abstract:</p>
<p class="OasisTitlePageInfoDescription">The Advanced Message Queuing Protocol (AMQP) is an open internet protocol for business
    messaging. It defines a binary wire-level protocol that allows for the reliable exchange
    of business messages between two parties.
    AMQP has a layered architecture and the specification is organized as a set of parts that
    reflects that architecture. Part 1 defines the AMQP type system and encoding. Part 2 defines
    the AMQP transport layer, an efficient, binary, peer-to-peer protocol for transporting messages
    between two processes over a network. Part 3 defines the AMQP message format, with a
    concrete encoding. Part 4 defines how interactions can be grouped within atomic
    transactions. Part 5 defines the AMQP security layers.</p>
<p class="OasisTitlePageInfo">Status:</p><p class="OasisTitlePageInfoDescription">
This document was last revised or approved by the membership of OASIS on the above date. The level of approval is also listed above. Check the "Latest version" location noted above for possible later revisions of this document.
</p><p class="OasisTitlePageInfoDescription">
Technical Committee members should send comments on this specification to the Technical Committee's email list. Others should send comments to the Technical Committee by using the "<a href="http://www.oasis-open.org/committees/comments/index.php?wg_abbrev=amqp">Send A Comment</a>" button on the Technical Committee's web page at <a href="http://www.oasis-open.org/committees/amqp/">http://www.oasis-open.org/committees/comments/amqp/</a>.
</p><p class="OasisTitlePageInfoDescription">For information on whether any patents have been disclosed that may be essential to implementing this specification, and any offers of patent licensing terms, please refer to the Intellectual Property Rights section of the Technical Committee web page (<a href="http://www.oasis-open.org/committees/amqp/ipr.php">http://www.oasis-open.org/committees/amqp/ipr.php</a>).
</p><p class="OasisTitlePageInfo">Citation format:</p><p class="OasisTitlePageInfoDescription">When referencing this specification the
following citation format should be used:</p><p class="OasisTitlePageInfoDescription"><b><span style="color:black">[amqp-core-transport-v1.0]</span></b></p><p class="OasisTitlePageInfoDescription"><i><span style="color:black">OASIS Advanced Message Queuing Protocol (AMQP) Version 1.0 Part 2: Transport</span></i><span style="color:black">.
29 October 2012. OASIS Standard. </span><span class="OasisHyperlink"><a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-transport-v1.0-os.html">http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-transport-v1.0-os.html</a></span><span style="color:black">.</span></p><hr><p class="OasisTitlePageInfo"><span style="font-size:12.0pt">Notices</span></p>
<p class="OasisTitlePageInfoDescription">
  Copyright &copy; OASIS Open 2012. All Rights Reserved.
</p>
<p class="OasisTitlePageInfoDescription">
  All capitalized terms in the following text have the meanings assigned to them in the OASIS
  Intellectual Property Rights Policy (the "OASIS IPR Policy"). The full <a href="http://www.oasis-open.org/policies-guidelines/ipr">Policy</a> may be found at the
  OASIS website.
</p>
<p class="OasisTitlePageInfoDescription">
  This document and translations of it may be copied and furnished to others, and derivative works
  that comment on or otherwise explain it or assist in its implementation may be prepared, copied,
  published, and distributed, in whole or in part, without restriction of any kind, provided that
  the above copyright notice and this section are included on all such copies and derivative works.
  However, this document itself may not be modified in any way, including by removing the copyright
  notice or references to OASIS, except as needed for the purpose of developing any document or
  deliverable produced by an OASIS Technical Committee (in which case the rules applicable to
  copyrights, as set forth in the OASIS IPR Policy, must be followed) or as required to translate
  it into languages other than English.
</p>
<p class="OasisTitlePageInfoDescription">
  The limited permissions granted above are perpetual and will not be revoked by OASIS or its
  successors or assigns.
</p>
<p class="OasisTitlePageInfoDescription">
  This document and the information contained herein is provided on an "AS IS" basis and OASIS
  DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE
  USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY OWNERSHIP RIGHTS OR ANY IMPLIED WARRANTIES OF
  MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
</p>
<p class="OasisTitlePageInfoDescription">
  OASIS requests that any OASIS Party or any other party that believes it has patent claims that
  would necessarily be infringed by implementations of this OASIS Committee Specification or OASIS
  Standard, to notify OASIS TC Administrator and provide an indication of its willingness to grant
  patent licenses to such patent claims in a manner consistent with the IPR Mode of the OASIS
  Technical Committee that produced this specification.
</p>
<p class="OasisTitlePageInfoDescription">
  OASIS invites any party to contact the OASIS TC Administrator if it is aware of a claim of
  ownership of any patent claims that would necessarily be infringed by implementations of this
  specification by a patent holder that is not willing to provide a license to such patent claims in
  a manner consistent with the IPR Mode of the OASIS Technical Committee that produced this
  specification. OASIS may include such claims on its website, but disclaims any obligation to do
  so.
</p>
<p class="OasisTitlePageInfoDescription">
  OASIS takes no position regarding the validity or scope of any intellectual property or other
  rights that might be claimed to pertain to the implementation or use of the technology described
  in this document or the extent to which any license under such rights might or might not be
  available; neither does it represent that it has made any effort to identify any such rights.
  Information on OASIS' procedures with respect to rights in any document or deliverable produced
  by an OASIS Technical Committee can be found on the OASIS website. Copies of claims of rights
  made available for publication and any assurances of licenses to be made available, or the result
  of an attempt made to obtain a general license or permission for the use of such proprietary
  rights by implementers or users of this OASIS Committee Specification or OASIS Standard, can be
  obtained from the OASIS TC Administrator. OASIS makes no representation that any information or
  list of intellectual property rights will at any time be complete, or that any claims in such list
  are, in fact, Essential Claims.
</p>
<p class="OasisTitlePageInfoDescription">
  The name "OASIS" is a trademark of <a href="http://www.oasis-open.org/">OASIS</a>, the owner and developer of this specification, and
  should be used only to refer to the organization and its official outputs. OASIS welcomes
  reference to, and implementation and use of, specifications, while reserving the right to enforce
  its marks against misleading uses. Please see <a href="http://www.oasis-open.org/policies-guidelines/trademark">http://www.oasis-open.org/policies-guidelines/trademark</a> for above guidance.
</p>
<hr><h2><a name="toc">Table of Contents</a></h2><br><br><table class="toc" summary="Table of Contents">

  

  <tr><td>2.1 <a href="#section-transport">Transport</a></td></tr><tr><td>      2.1.1 <a href="#doc-idp2176">conceptual model</a></td></tr><tr><td>      2.1.2 <a href="#doc-idp48736">communication endpoints</a></td></tr><tr><td>      2.1.3 <a href="#doc-idp31280">protocol frames</a></td></tr>

  <tr><td>2.2 <a href="#section-version-negotiation">Version Negotiation</a></td></tr>

  <tr><td>2.3 <a href="#section-framing">Framing</a></td></tr><tr><td>      2.3.1 <a href="#doc-idp124752">Frame Layout</a></td></tr><tr><td>      2.3.2 <a href="#doc-idp134416">AMQP Frames</a></td></tr>

  

  <tr><td>2.4 <a href="#section-connections">Connections</a></td></tr><tr><td>      2.4.1 <a href="#doc-idp150480">Opening a Connection</a></td></tr><tr><td>      2.4.2 <a href="#doc-idp157520">Pipelined Open</a></td></tr><tr><td>      2.4.3 <a href="#doc-idp162944">Closing a Connection</a></td></tr><tr><td>      2.4.4 <a href="#doc-idp170544">Simultaneous Close</a></td></tr><tr><td>      2.4.5 <a href="#doc-doc-idle-time-out">Idle Timeout of a Connection</a></td></tr><tr><td>      2.4.6 <a href="#doc-idp184736">Connection States</a></td></tr><tr><td>      2.4.7 <a href="#doc-idp211568">Connection State Diagram</a></td></tr>

  

  <tr><td>2.5 <a href="#section-sessions">Sessions</a></td></tr><tr><td>      2.5.1 <a href="#doc-idp223280">Establishing a Session</a></td></tr><tr><td>      2.5.2 <a href="#doc-idp230944">Ending a Session</a></td></tr><tr><td>      2.5.3 <a href="#doc-idp235408">Simultaneous End</a></td></tr><tr><td>      2.5.4 <a href="#doc-idp239696">Session Errors</a></td></tr><tr><td>      2.5.5 <a href="#doc-idp243424">Session States</a></td></tr><tr><td>      2.5.6 <a href="#doc-session-flow-control">Session Flow Control</a></td></tr>

  

  <tr><td>2.6 <a href="#section-links">Links</a></td></tr><tr><td>      2.6.1 <a href="#doc-idp298752">Naming a Link</a></td></tr><tr><td>      2.6.2 <a href="#doc-link-handles">Link Handles</a></td></tr><tr><td>      2.6.3 <a href="#doc-idp315568">Establishing or Resuming a Link</a></td></tr><tr><td>      2.6.4 <a href="#doc-idp339696">Detaching and Reattaching a Link</a></td></tr><tr><td>      2.6.5 <a href="#doc-idp348080">Link Errors</a></td></tr><tr><td>      2.6.6 <a href="#doc-closing-a-link">Closing a Link</a></td></tr><tr><td>      2.6.7 <a href="#doc-flow-control">Flow Control</a></td></tr><tr><td>      2.6.8 <a href="#doc-idp416352">Synchronous Get</a></td></tr><tr><td>      2.6.9 <a href="#doc-idp424576">Asynchronous Notification</a></td></tr><tr><td>      2.6.10 <a href="#doc-idp429232">Stopping a Link</a></td></tr><tr><td>      2.6.11 <a href="#doc-idp434960">Messages</a></td></tr><tr><td>      2.6.12 <a href="#doc-idp438000">Transferring a Message</a></td></tr><tr><td>      2.6.13 <a href="#doc-resuming-deliveries">Resuming Deliveries</a></td></tr><tr><td>      2.6.14 <a href="#doc-idp484080">Transferring Large Messages</a></td></tr>

  <tr><td>2.7 <a href="#section-performatives">Performatives</a></td></tr><tr><td>      2.7.1 <a href="#type-open">Open</a></td></tr><tr><td>      2.7.2 <a href="#type-begin">Begin</a></td></tr><tr><td>      2.7.3 <a href="#type-attach">Attach</a></td></tr><tr><td>      2.7.4 <a href="#type-flow">Flow</a></td></tr><tr><td>      2.7.5 <a href="#type-transfer">Transfer</a></td></tr><tr><td>      2.7.6 <a href="#type-disposition">Disposition</a></td></tr><tr><td>      2.7.7 <a href="#type-detach">Detach</a></td></tr><tr><td>      2.7.8 <a href="#type-end">End</a></td></tr><tr><td>      2.7.9 <a href="#type-close">Close</a></td></tr>

  <tr><td>2.8 <a href="#section-definitions">Definitions</a></td></tr><tr><td>      2.8.1 <a href="#type-role">Role</a></td></tr><tr><td>      2.8.2 <a href="#type-sender-settle-mode">Sender Settle Mode</a></td></tr><tr><td>      2.8.3 <a href="#type-receiver-settle-mode">Receiver Settle Mode</a></td></tr><tr><td>      2.8.4 <a href="#type-handle">Handle</a></td></tr><tr><td>      2.8.5 <a href="#type-seconds">Seconds</a></td></tr><tr><td>      2.8.6 <a href="#type-milliseconds">Milliseconds</a></td></tr><tr><td>      2.8.7 <a href="#type-delivery-tag">Delivery Tag</a></td></tr><tr><td>      2.8.8 <a href="#type-delivery-number">Delivery Number</a></td></tr><tr><td>      2.8.9 <a href="#type-transfer-number">Transfer Number</a></td></tr><tr><td>      2.8.10 <a href="#type-sequence-no">Sequence No</a></td></tr><tr><td>      2.8.11 <a href="#type-message-format">Message Format</a></td></tr><tr><td>      2.8.12 <a href="#type-ietf-language-tag">Ietf Language Tag</a></td></tr><tr><td>      2.8.13 <a href="#type-fields">Fields</a></td></tr><tr><td>      2.8.14 <a href="#type-error">Error</a></td></tr><tr><td>      2.8.15 <a href="#type-amqp-error">Amqp Error</a></td></tr><tr><td>      2.8.16 <a href="#type-connection-error">Connection Error</a></td></tr><tr><td>      2.8.17 <a href="#type-session-error">Session Error</a></td></tr><tr><td>      2.8.18 <a href="#type-link-error">Link Error</a></td></tr><tr><td>      2.8.19 <a href="#definition-idp861488">Constant Definitions</a></td></tr>

</table><hr>

  

  <h2><a class="toc" href="#toc">←</a>2.1 <a name="section-transport">Transport</a></h2><div class="section"><h3><a class="toc" href="#toc">←</a>2.1.1 <a name="doc-idp2176">Conceptual Model</a></h3><div class="doc"><p>
        An AMQP network consists of <i>nodes</i> connected via <i>links</i>. Nodes are
        named entities responsible for the safe storage and/or delivery of <i>messages</i>.
        Messages can originate from, terminate at, or be relayed by nodes.
      </p><p>
        A link is a unidirectional route between two nodes. A link attaches to a node at
        a <i>terminus</i>. There are two kinds of terminus: <i>sources</i>
        and <i>targets</i>. A terminus is responsible for tracking the state of a particular
        stream of incoming or outgoing messages. Sources track outgoing messages and targets track
        incoming messages. Messages only travel along a link if they meet the entry criteria at
        the source.
      </p><p>
        As a message travels through an AMQP network, the responsibility for safe storage and
        delivery of the message is transferred between the nodes it encounters. The
        <i>link protocol</i> (defined in <a href="#section-links" title="links">section 2.6</a>) manages the transfer of
        responsibility between the source and target.
      </p><table class="pre" summary="Message Transfer between Nodes"><caption style="caption-side:bottom">Figure 2.1: Message Transfer between Nodes</caption><tr><td>
        
  +------------+                             +------------+
 /    Node A    \                           /    Node B    \
+----------------+    +--filter            +----------------+
|                |   /                     |                |
|  MSG_3 &lt;MSG_1&gt; | _/                    _ |         MSG_1  |
|                |(_)------------------&gt;(_)|                |
| &lt;MSG_2&gt; MSG_4  | |                     | |  MSG_2         |
|                | |    Link(Src,Tgt)    | |                |
+----------------+ |                     | +----------------+
                   |                     |
                  Src                   Tgt


            Key: &lt;MSG_n&gt; = old location of MSG_n 
      </td></tr></table><p>
        Nodes exist within a <i>container</i>. Examples of containers are
        <i>brokers</i> and <i>client</i> applications. Each container MAY hold many
        nodes. Examples of AMQP nodes are <i>producers</i>, <i>consumers</i>, and
        <i>queues</i>. Producers and consumers are the elements within an application that
        generate and process messages. Queues are entities that store and forward messages.
      </p><table class="pre" summary="Class Diagram of Concrete Containers and Nodes"><caption style="caption-side:bottom">Figure 2.2: Class Diagram of Concrete Containers and Nodes</caption><tr><td>
        
   +---------------+                       +----------+
   | &lt;&lt;Container&gt;&gt; | 1..1             0..n | &lt;&lt;Node&gt;&gt; |
   |---------------|&lt;&gt;--------------------&gt;|----------|
   | container-id  |                       | name     |
   +---------------+                       +----------+
          /_\                                   /_\
           |                                     |
           |                                     |
     +-----+-----+                    +----------+----------+
     |           |                    |          |          |
     |           |                    |          |          |
+--------+  +--------+        +----------+  +----------+  +-------+
| Broker |  | Client |        | Producer |  | Consumer |  | Queue |
|--------|  |--------|        |----------|  |----------|  |-------|
|        |  |        |        |          |  |          |  |       |
+--------+  +--------+        +----------+  +----------+  +-------+
      </td></tr></table></div><h3><a class="toc" href="#toc">←</a>2.1.2 <a name="doc-idp48736">Communication Endpoints</a></h3><div class="doc"><p>
        The AMQP transport specification defines a peer-to-peer protocol for transferring messages
        between nodes in an AMQP network. This portion of the specification is not concerned with
        the internal workings of any sort of node, and only deals with the mechanics of
        unambiguously transferring a message from one node to another.
      </p><p>
        In order for communication to occur between nodes in different containers a connection
        needs be established.
      </p><table class="pre" summary="An AMQP Connection"><caption style="caption-side:bottom">Figure 2.3: An AMQP Connection</caption><tr><td>
        
  Client App                                        Broker
+-------------+                                +-------------+
|             |################################|             |
|   +---+     |                                |    +---+    |
|   | C |     |           Connection           |    | Q |    |
|   +-+-+     |                                |    +-+-+    |
|     |       |################################|      |      |
+-----|-------+                                +------|------+
      |                                               |
   Consumer                                         Queue
    (Node)                                          (Node)
      </td></tr></table><p>
        An AMQP connection consists of a full-duplex, reliably ordered sequence of
        <i>frames</i>. A frame is the unit of work carried on the wire. Connections have a
        negotiated maximum frame size allowing byte streams to be easily defragmented into complete
        frame bodies representing the independently parsable units formally defined in
        <a href="#section-performatives" title="performatives">section 2.7</a>. The precise requirement for a connection is that if the
        n<sup>th</sup> frame arrives, all frames prior to n MUST also have arrived. It is assumed
        connections are transient and can fail for a variety of reasons resulting in the loss of
        an unknown number of frames, but they are still subject to the aforementioned ordered
        reliability criteria. This is similar to the guarantee that TCP or SCTP provides for byte
        streams, and the specification defines a framing system used to parse a byte stream into
        a sequence of frames for use in establishing an AMQP connection (see
        <a href="#section-framing" title="framing">section 2.3</a>).
      </p><p>
        An AMQP connection is divided into a negotiated number of independent unidirectional
        <i>channels</i>. Each frame is marked with the channel number indicating its parent
        channel, and the frame sequence for each channel is multiplexed into a single frame
        sequence for the connection.
      </p><p>
        An AMQP <i>session</i> correlates two unidirectional channels to form a
        bidirectional, sequential conversation between two containers. Sessions provide a flow
        control scheme based on the number of <i>transfer frames</i> transmitted. Since
        frames have a maximum size for a given connection, this provides flow control based on the
        number of bytes transmitted and can be used to optimize performance.
        </p><table class="pre" summary="An AMQP Session"><caption style="caption-side:bottom">Figure 2.4: An AMQP Session</caption><tr><td>
        
  Client App                                        Broker
+-------------+                                +-------------+
|             |################################|             |
|   +---+     |--------------------------------|    +---+    |
|   | C |     |            Session             |    | Q |    |
|   +---+     |--------------------------------|    +---+    |
|             |################################|             |
+-------------+                                +-------------+
      </td></tr></table><p>
        A single connection MAY have multiple independent sessions active simultaneously, up to
        the negotiated channel limit. Both connections and sessions are modeled by each peer as
        <i>endpoints</i> that store local and last known remote state regarding the
        connection or session in question.
      </p><table class="pre" summary="Session &amp; Connection Endpoints"><caption style="caption-side:bottom">Figure 2.5: Session &amp; Connection Endpoints</caption><tr><td>
        
    Session&lt;------+                           +------&gt;Session
(ICH=1, OCH=1)    |                           |    (ICH=1, OCH=1)
                 \|/                         \|/
    Session&lt;--&gt; Connection &lt;---------&gt; Connection &lt;--&gt;Session
(ICH=2, OCH=3)   /|\                         /|\   (ICH=3, OCH=2)
                  |                           |
    Session&lt;------+                           +------&gt;Session
(ICH=3, OCH=2)                                     (ICH=2, OCH=3)

        Key: ICH -&gt; Input Channel, OCH -&gt; Output Channel 
      </td></tr></table><p>
        In order to transfer messages between nodes (e.g., to move messages from a queue to a
        consumer) a <i>link</i> needs to be established between the nodes. A link is a
        unidirectional route between two nodes.
        A link attaches to a node at a terminus. There are two kinds of terminus: sources and
        targets. A terminus is responsible for tracking the state of a particular stream of
        incoming or outgoing messages. Sources track outgoing messages and targets track incoming
        messages. Messages only travel along a link if they meet the entry criteria at the source.
      </p><p>
        Links provide a credit-based flow control scheme based on the number of messages
        transmitted, allowing applications to control which nodes to receive messages from at a
        given point (e.g., to explicitly fetch a message from a given queue).
      </p><table class="pre" summary="An AMQP Link"><caption style="caption-side:bottom">Figure 2.6: An AMQP Link</caption><tr><td>
        
  Client App                                        Broker
+-------------+                                +-------------+
|             |################################|             |
|   +---+     |--------------------------------|    +---+    |
|   | C |O&lt;=================+======================O| Q |    |
|   +---+ \   |-------------|------------------|   |+---+    |
|          \  |#############|##################|   |         |
+-----------\-+             |                  +---|---------+
             \              |                      |
            Target          |                    Source
                           Link
      </td></tr></table><p>
        Sessions provide the context for communication between sources and targets.
        A <i>link endpoint</i> associates a terminus with a <i>session endpoint</i>.
        Within a session, the link protocol (defined in <a href="#section-links" title="links">section 2.6</a>) is used to establish
        links between sources and targets and to transfer messages across them. A single session
        can be simultaneously associated with any number of links.
      </p><p>
        Links are named, and the state at the termini can live longer than the connection on which
        they were established.
      </p><table class="pre" summary="Connection Loss"><caption style="caption-side:bottom">Figure 2.7: Connection Loss</caption><tr><td>
        
  Client App                                        Broker
+-------------+                                +-------------+
|             |                                |             |
|   +---+     |                                |    +---+    |
|   | C |O&lt;=| |                                | |=O| Q |    |
|   +---+|    |                                |   |+---+    |
|        |    |                                |   |         |
+--------|----+                                +---|---------+
         |                                         |
         |                                         |
  State retained                            State retained
    at Target                                 at Source
      </td></tr></table><p>
        The retained state at the termini can be used to reestablish the link on a new connection
        (and session) with precise control over delivery guarantees (e.g., ensuring "exactly once"
        delivery).
      </p><table class="pre" summary="Link Recovery"><caption style="caption-side:bottom">Figure 2.8: Link Recovery</caption><tr><td>
        
  Client App                                        Broker
+-------------+                                +-------------+
|             |################################|             |
|   +---+     |--------------------------------|    +---+    |
|   | C |O&lt;========================================O| Q |    |
|   +---+     |--------------------------------|    +---+    |
|             |################################|             |
+-------------+                                +-------------+
      </td></tr></table><p>
        The diagram below shows the relationship between the three AMQP communication endpoints,
        Connection, Session and Link.
      </p><table class="pre" summary="Class Diagram of Communication Endpoints"><caption style="caption-side:bottom">Figure 2.9: Class Diagram of Communication Endpoints</caption><tr><td>
        
+-------------+
|    Link     |  Message Transport
+-------------+  (Node to Node)
| name        |
| source      |
| target      |
| timeout     |
+-------------+
     /|\ 0..n
      |
      |
      |
     \|/ 0..1
+------------+
|  Session   |  Frame Transport
+------------+  (Container to Container)
| name       |
+------------+
     /|\ 0..n
      |
      |
      |
     \|/ 1..1
+------------+
| Connection |  Frame Transport
+------------+  (Container to Container)
| principal  |
+------------+ 
      </td></tr></table></div><h3><a class="toc" href="#toc">←</a>2.1.3 <a name="doc-idp31280">Protocol Frames</a></h3><div class="doc"><p>
        The protocol consists of nine frame body types that are formally defined in
        <a href="#section-performatives" title="performatives">section 2.7</a>. The following table lists the frame bodies and
        defines which endpoints handle them.
      </p><table class="pre" summary="Frame Dispatch Table"><caption style="caption-side:bottom">Figure 2.10: Frame Dispatch Table</caption><tr><td>
        
Frame          Connection  Session  Link
========================================
open               H
begin              I          H
attach                        I      H
flow                          I      H
transfer                      I      H
disposition                   I      H
detach                        I      H
end                I          H
close              H
----------------------------------------

Key:
     H: handled by the endpoint

     I: intercepted (endpoint examines
        the frame, but delegates
        further processing to another
        endpoint) 
      </td></tr></table></div></div>

  <h2><a class="toc" href="#toc">←</a>2.2 <a name="section-version-negotiation">Version Negotiation</a></h2><div class="section"><div class="doc"><p>
        Prior to sending any frames on a connection, each peer MUST start by sending a protocol
        header that indicates the protocol version used on the connection. The protocol header
        consists of the upper case ASCII letters "AMQP" followed by a protocol id of zero, followed
        by three unsigned bytes representing the major, minor, and revision of the protocol version
        (currently <a href="#definition-MAJOR">1 (MAJOR)</a>, <a href="#definition-MINOR">0 (MINOR)</a>, <a href="#definition-REVISION">0 (REVISION)</a>). In total
        this is an 8-octet sequence:
      </p><table class="pre" summary="Protocol Header Layout"><caption style="caption-side:bottom">Figure 2.11: Protocol Header Layout</caption><tr><td>
  4 OCTETS   1 OCTET   1 OCTET   1 OCTET   1 OCTET
+----------+---------+---------+---------+----------+
|  "AMQP"  |   %d0   |  major  |  minor  | revision |
+----------+---------+---------+---------+----------+
      </td></tr></table><p>
        Any data appearing beyond the protocol header MUST match the version indicated by the
        protocol header. If the incoming and outgoing protocol headers do not match, both peers MUST
        close their outgoing stream and SHOULD read the incoming stream until it is terminated.
      </p><p>
        The AMQP peer which acted in the role of the TCP client (i.e. the peer that actively opened
        the connection) MUST immediately send its outgoing protocol header on establishment of the
        TCP connection. The AMQP peer which acted in the role of the TCP server MAY elect to wait
        until receiving the incoming protocol header before sending its own outgoing protocol
        header. This permits a multi protocol server implementation to choose the correct protocol
        version to fit each client.
      </p><p>
        Two AMQP peers agree on a protocol version as follows (where the words "client" and
        "server" refer to the roles being played by the peers at the TCP connection level):
      </p><ul>
        <li>
          <p>
            When the client opens a new socket connection to a server, it MUST send a protocol
            header with the client's preferred protocol version.
          </p>
        </li>

        <li>
          <p>
            If the requested protocol version is supported, the server MUST send its own protocol
            header with the requested version to the socket, and then proceed according to the
            protocol definition.
          </p>
        </li>

        <li>
          <p>
            If the requested protocol version is <b>not</b> supported, the server MUST send a
            protocol header with a <b>supported</b> protocol version and then close the socket.
          </p>
        </li>

        <li>
          <p>
            When choosing a protocol version to respond with, the server SHOULD choose the highest
            supported version that is less than or equal to the requested version. If no such
            version exists, the server SHOULD respond with the highest supported version.
          </p>
        </li>

        <li>
          <p>
            If the server cannot parse the protocol header, the server MUST send a valid protocol
            header with a supported protocol version and then close the socket.
          </p>
        </li>

        <li>
          <p>
            Note that if the server only supports a single protocol version, it is consistent with
            the above rules for the server to send its protocol header prior to receiving anything
            from the client and to subsequently close the socket if the client's protocol header
            does not match the server's.
          </p>
        </li>
      </ul><p>
        Based on this behavior a client can discover which protocol versions a server supports by
        attempting to connect with its highest supported version and reconnecting with a version
        less than or equal to the version received back from the server.
      </p><table class="pre" summary="Version Negotiation Examples"><caption style="caption-side:bottom">Figure 2.12: Version Negotiation Examples</caption><tr><td>
TCP Client                               TCP Server
======================================================
AMQP%d0.1.0.0       -------------&gt;
                    &lt;-------------       AMQP%d0.1.0.0 (1)
                          ...            *proceed*

AMQP%d0.1.1.0       -------------&gt;
                    &lt;-------------       AMQP%d0.1.0.0 (2)
                                         *TCP CLOSE*

HTTP                -------------&gt;
                    &lt;-------------       AMQP%d0.1.0.0 (3)
                                         *TCP CLOSE*
------------------------------------------------------
  (1) Server accepts connection for: AMQP, protocol=0,
      major=1, minor=0, revision=0

  (2) Server rejects connection for: AMQP, protocol=0,
      major=1, minor=1, revision=0, Server responds
      that it supports: AMQP, protocol=0, major=1,
      minor=0, revision=0

  (3) Server rejects connection for: HTTP. Server
      responds it supports: AMQP, protocol=0, major=1,
       minor=0, revision=0 
      </td></tr></table><p>
        Please note that the above examples use the literal notation defined in RFC 2234
        [<a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-overview-v1.0-os.html#anchor-RFC2234">RFC2234</a>] for non alphanumeric values.
      </p><p>
        The protocol id is not a part of the protocol version and thus the rule above regarding
        the highest supported version does not apply. A client might request use of a protocol id
        that is unacceptable to a server - for example, it might request a raw AMQP connection
        when the server is configured to require a TLS or SASL security layer (See <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-security-v1.0-os.html#section-security-layers" title="security-layers">section 5.1</a>). In this case, the server MUST send a protocol
        header with an <b>acceptable</b> protocol id (and version) and then close the socket. It MAY
        choose any protocol id.
      </p><table class="pre" summary="Protocol ID Rejection Example"><caption style="caption-side:bottom">Figure 2.13: Protocol ID Rejection Example</caption><tr><td>
TCP Client                               TCP Server
======================================================
AMQP%d0.1.0.0       -------------&gt;
                    &lt;-------------       AMQP%d3.1.0.0
                                         *TCP CLOSE*
------------------------------------------------------
      Server rejects connection for: AMQP, protocol=0,
      major=1, minor=0, revision=0, Server responds
      that it requires: SASL security layer, protocol=3,
      major=1, minor=0, revision=0 
      </td></tr></table></div></div>

  <h2><a class="toc" href="#toc">←</a>2.3 <a name="section-framing">Framing</a></h2><div class="section"><div class="doc"><p>
        Frames are divided into three distinct areas: a fixed width frame header, a variable width
        extended header, and a variable width frame body.
      </p><table class="pre" summary="Frame Layout"><caption style="caption-side:bottom">Figure 2.14: Frame Layout</caption><tr><td>
    REQUIRED        OPTIONAL        OPTIONAL
+--------------+-----------------+------------+
| frame header | extended header | frame body |
+--------------+-----------------+------------+
    8 bytes        *variable*      *variable* 
      </td></tr></table><dl>
        <dt>frame header</dt>
        <dd><p>The frame header is a fixed size (8 byte) structure that precedes each frame. The
            frame header includes mandatory information necessary to parse the rest of the frame
            including size and type information.</p></dd>

        <dt>extended header</dt>
        <dd><p>The extended header is a variable width area preceding the frame body. This is an
            extension point defined for future expansion. The treatment of this area depends on the
            frame type.</p></dd>

        <dt>frame body</dt>
        <dd><p>The frame body is a variable width sequence of bytes the format of which depends on
            the frame type.</p></dd>
      </dl></div><h3><a class="toc" href="#toc">←</a>2.3.1 <a name="doc-idp124752">Frame Layout</a></h3><div class="doc"><p>
        The diagram below shows the details of the general frame layout for all frame types.
      </p><table class="pre" summary="General Frame Layout"><caption style="caption-side:bottom">Figure 2.15: General Frame Layout</caption><tr><td>
           +0       +1       +2       +3
       +-----------------------------------+ -.
     0 |                SIZE               |  |
       +-----------------------------------+  |---&gt; Frame Header
     4 |  DOFF  |  TYPE  | &lt;TYPE-SPECIFIC&gt; |  |      (8 bytes)
       +-----------------------------------+ -'
       +-----------------------------------+ -.
     8 |                ...                |  |
       .                                   .  |---&gt; Extended Header
       .          &lt;TYPE-SPECIFIC&gt;          .  |  (DOFF * 4 - 8) bytes
       |                ...                |  |
       +-----------------------------------+ -'
       +-----------------------------------+ -.
4*DOFF |                                   |  |
       .                                   .  |
       .                                   .  |
       .                                   .  |
       .          &lt;TYPE-SPECIFIC&gt;          .  |---&gt; Frame Body
       .                                   .  |  (SIZE - DOFF * 4) bytes
       .                                   .  |
       .                                   .  |
       .                           ________|  |
       |                ...       |           |
       +--------------------------+          -' 
      </td></tr></table><dl>
        <dt>SIZE</dt>
        <dd><p>Bytes 0-3 of the frame header contain the frame size. This is an unsigned 32-bit
            integer that MUST contain the total frame size of the frame header, extended header, and
            frame body. The frame is malformed if the size is less than the size of the
            frame header (8 bytes).</p></dd>

        <dt>DOFF</dt>
        <dd><p>Byte 4 of the frame header is the data offset. This gives the position of the body
            within the frame. The value of the data offset is an unsigned, 8-bit integer specifying
            a count of 4-byte words. Due to the mandatory 8-byte frame header, the frame is
            malformed if the value is less than 2.</p></dd>

        <dt>TYPE</dt>
        <dd><p>Byte 5 of the frame header is a type code. The type code indicates the format and
            purpose of the frame. The subsequent bytes in the frame header MAY be interpreted
            differently depending on the type of the frame. A type code of 0x00 indicates that the
            frame is an AMQP frame. A type code of 0x01 indicates that the frame is a SASL frame,
            see <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-security-v1.0-os.html#section-sasl" title="sasl">section 5.3</a>.
         </p></dd>
      </dl></div><h3><a class="toc" href="#toc">←</a>2.3.2 <a name="doc-idp134416">AMQP Frames</a></h3><div class="doc"><p>
        Bytes 6 and 7 of an AMQP frame contain the channel number (see <a href="#section-transport" title="transport">section 2.1</a>).
        The frame body is defined as a <i>performative</i> followed by an opaque <i>payload</i>. The
        performative MUST be one of those defined in <a href="#section-performatives" title="performatives">section 2.7</a> and is encoded as
        a described type in the AMQP type system. The remaining bytes in the frame body form the
        payload for that frame. The presence and format of the payload is defined by the semantics
        of the given performative.
      </p><table class="pre" summary="AMQP Frame Layout"><caption style="caption-side:bottom">Figure 2.16: AMQP Frame Layout</caption><tr><td>
              type: 0x00 - AMQP frame

           +0       +1       +2       +3
       +-----------------------------------+ -.
     0 |                SIZE               |  |
       +-----------------------------------+  |---&gt; Frame Header
     4 |  DOFF  |  TYPE  |     CHANNEL     |  |      (8 bytes)
       +-----------------------------------+ -'
       +-----------------------------------+ -.
     8 |                ...                |  |
       .                                   .  |---&gt; Extended Header
       .             &lt;IGNORED&gt;             .  |  (DOFF * 4 - 8) bytes
       |                ...                |  |
       +-----------------------------------+ -'
       +-----------------------------------+ -.
4*DOFF |           PERFORMATIVE:           |  |
       .      Open / Begin / Attach        .  |
       .   Flow / Transfer / Disposition   .  |
       .      Detach / End / Close         .  |
       |-----------------------------------|  |
       .                                   .  |---&gt; Frame Body
       .                                   .  |  (SIZE - DOFF * 4) bytes
       .             PAYLOAD               .  |
       .                                   .  |
       .                           ________|  |
       |                ...       |           |
       +--------------------------+          -' 
      </td></tr></table><p>
        An AMQP frame with no body MAY be used to generate artificial traffic as needed to
        satisfy any negotiated idle timeout interval (see <a href="#doc-doc-idle-time-out" title="doc-idle-time-out">subsection 2.4.5</a>).
      </p></div></div>

  

  <h2><a class="toc" href="#toc">←</a>2.4 <a name="section-connections">Connections</a></h2><div class="section"><div class="doc"><p>
        AMQP connections are divided into a number of unidirectional channels. A connection endpoint
        contains two kinds of channel endpoints: incoming and outgoing. A connection endpoint maps
        incoming frames other than <a href="#type-open">open</a> and <a href="#type-close">close</a> to an incoming
        channel endpoint based on the incoming channel number, as well as relaying frames produced
        by outgoing channel endpoints, marking them with the associated outgoing channel number
        before sending them.
      </p><p>
        This requires connection endpoints to contain two mappings. One from incoming channel number
        to incoming channel endpoint, and one from outgoing channel endpoint, to outgoing channel
        number.
      </p><table class="pre" summary="Unidirectional Channel Multiplexing"><caption style="caption-side:bottom">Figure 2.17: Unidirectional Channel Multiplexing</caption><tr><td>
                                  +-------OCHE X: 1
                                  |
                                  +-------OCHE Y: 7
                                  |
&lt;=== Frame[CH=1], Frame[CH=7] &lt;===+

===&gt; Frame[CH=0], Frame[CH=1] ===&gt;+
                                  |
                                  +------&gt;0: ICHE A
                                  |
                                  +------&gt;1: ICHE B

  OCHE: Outgoing Channel Endpoint
  ICHE: Incoming Channel Endpoint 
      </td></tr></table><p>
        Channels are unidirectional, and thus at each connection endpoint the incoming and outgoing
        channels are completely distinct. Channel numbers are scoped relative to direction, thus
        there is no causal relation between incoming and outgoing channels that happen to be
        identified by the same number. This means that if a bidirectional endpoint is constructed
        from an incoming channel endpoint and an outgoing channel endpoint, the channel number used
        for incoming frames is not necessarily the same as the channel number used for outgoing
        frames.
      </p><table class="pre" summary="Bidirectional Channel Multiplexing"><caption style="caption-side:bottom">Figure 2.18: Bidirectional Channel Multiplexing</caption><tr><td>
                                  +-------BIDI/O: 7
                                  |
&lt;=== Frame[CH=1], Frame[CH=7] &lt;===+

===&gt; Frame[CH=0], Frame[CH=1] ===&gt;+
                                  |
                                  +------&gt;1: BIDI/I

  BIDI/I: Incoming half of a single bidirectional endpoint
  BIDI/O: Outgoing half of a single bidirectional endpoint 
      </td></tr></table><p>
        Although not strictly directed at the connection endpoint, the <a href="#type-begin">begin</a> and
        <a href="#type-end">end</a> frames are potentially useful for the connection endpoint to intercept
        as these frames are how sessions mark the beginning and ending of communication on a given
        channel (see <a href="#section-sessions" title="sessions">section 2.5</a>).
      </p></div><h3><a class="toc" href="#toc">←</a>2.4.1 <a name="doc-idp150480">Opening A Connection</a></h3><div class="doc"><p>
        Each AMQP connection begins with an exchange of capabilities and limitations, including the
        maximum frame size. Prior to any explicit negotiation, the maximum frame size is <a href="#definition-MIN-MAX-FRAME-SIZE">512 (MIN-MAX-FRAME-SIZE)</a> and the maximum channel number is 0. After establishing or
        accepting a TCP connection and sending the protocol header, each peer MUST send an <a href="#type-open">open</a> frame before sending any other frames. The <a href="#type-open">open</a> frame describes the capabilities and limits of that peer. The <a href="#type-open">open</a> frame can only be sent on channel 0. After sending the <a href="#type-open">open</a> frame and reading its partner's <a href="#type-open">open</a>
        frame a peer MUST operate within mutually acceptable limitations from this point forward.
      </p><table class="pre" summary="Synchronous Connection Open Sequence"><caption style="caption-side:bottom">Figure 2.19: Synchronous Connection Open Sequence</caption><tr><td>
TCP Client              TCP Server
==================================
TCP-CONNECT             TCP-ACCEPT
PROTO-HDR               PROTO-HDR
OPEN        ---+   +--- OPEN
                \ /
wait             x      wait
                / \
proceed     &lt;--+   +--&gt; proceed

                ...  
      </td></tr></table></div><h3><a class="toc" href="#toc">←</a>2.4.2 <a name="doc-idp157520">Pipelined Open</a></h3><div class="doc"><p>
        For applications that use many short-lived connections, it MAY be desirable to pipeline the
        connection negotiation process. A peer MAY do this by starting to send subsequent frames
        before receiving the partner's connection header or <a href="#type-open">open</a> frame.
        This is permitted so long as the pipelined frames are known <i>a priori</i> to conform to
        the capabilities and limitations of its partner. For example, this can be accomplished by
        keeping the use of the connection within the capabilities and limits expected of all AMQP
        implementations as defined by the specification of the <a href="#type-open">open</a>
        frame.
      </p><table class="pre" summary="Pipelined Connection Open Sequence"><caption style="caption-side:bottom">Figure 2.20: Pipelined Connection Open Sequence</caption><tr><td>
TCP Client                    TCP Server
=============================================
TCP-CONNECT                   TCP-ACCEPT
PROTO-HDR                     PROTO-HDR
OPEN              ---+   +--- OPEN
                      \ /
pipelined frame        x      pipelined frame
                      / \
proceed           &lt;--+   +--&gt; proceed

                      ...
--------------------------------------------- 
      </td></tr></table><p>
        The use of pipelined frames by a peer cannot be distinguished by the peer's partner from
        non-pipelined use so long as the pipelined frames conform to the partner's capabilities and
        limitations.
      </p></div><h3><a class="toc" href="#toc">←</a>2.4.3 <a name="doc-idp162944">Closing A Connection</a></h3><div class="doc"><p>
        Prior to closing a connection, each peer MUST write a <a href="#type-close">close</a> frame
        with a code indicating the reason for closing. This frame MUST be the last thing ever
        written onto a connection. After writing this frame the peer SHOULD continue to read from
        the connection until it receives the partner's <a href="#type-close">close</a> frame (in
        order to guard against erroneously or maliciously implemented partners, a peer SHOULD
        implement a timeout to give its partner a reasonable time to receive and process the close
        before giving up and simply closing the underlying transport mechanism). A <a href="#type-close">close</a> frame MAY be received on any channel up to the maximum channel number
        negotiated in open. However, implementations SHOULD send it on channel 0, and MUST send it
        on channel 0 if pipelined in a single batch with the corresponding <a href="#type-open">open</a>.
      </p><table class="pre" summary="Synchronous Connection Close Sequence"><caption style="caption-side:bottom">Figure 2.21: Synchronous Connection Close Sequence</caption><tr><td>
TCP Client         TCP Server
=============================
            ...

CLOSE     -------&gt;
               +-- CLOSE
              /    TCP-CLOSE
TCP-CLOSE &lt;--+ 
      </td></tr></table><p>
       Implementations SHOULD NOT expect to be able to reuse open TCP sockets after <a href="#type-close">close</a> performatives have been exchanged. There is no requirement for an
       implementation to read from a socket after a <a href="#type-close">close</a> performative
       has been received.
     </p></div><h3><a class="toc" href="#toc">←</a>2.4.4 <a name="doc-idp170544">Simultaneous Close</a></h3><div class="doc"><p>
        Normally one peer will initiate the connection close, and the partner will send its close in
        response. However, because both endpoints MAY simultaneously choose to close the connection
        for independent reasons, it is possible for a simultaneous close to occur. In this case, the
        only potentially observable difference from the perspective of each endpoint is the code
        indicating the reason for the close.
      </p><table class="pre" summary="Simultaneous Connection Close Sequence"><caption style="caption-side:bottom">Figure 2.22: Simultaneous Connection Close Sequence</caption><tr><td>
TCP Client            TCP Server
================================
              ...

CLOSE     ---+   +--- CLOSE
              \ /
               x
              / \
TCP-CLOSE &lt;--+   +--&gt; TCP-CLOSE 
      </td></tr></table></div><h3><a class="toc" href="#toc">←</a>2.4.5 <a name="doc-doc-idle-time-out">Idle Timeout Of A Connection</a></h3><div class="doc"><p>
        Connections are subject to an idle timeout threshold. The timeout is triggered by a local
        peer when no frames are received after a threshold value is exceeded. The idle timeout is
        measured in milliseconds, and starts from the time the last frame is received. If the
        threshold is exceeded, then a peer SHOULD try to gracefully close the connection using a
        <a href="#type-close">close</a> frame with an error explaining why. If the remote peer does
        not respond gracefully within a threshold to this, then the peer MAY close the TCP socket.
      </p><p>
        Each peer has its own (independent) idle timeout. At connection open each peer communicates
        the maximum period between activity (frames) on the connection that it desires from its
        partner.The <a href="#type-open">open</a> frame carries the idle-time-out field for this
        purpose. To avoid spurious timeouts, the value in idle-time-out SHOULD be half the peer's
        actual timeout threshold.
      </p><p>
        If a peer can not, for any reason support a proposed idle timeout, then it SHOULD close
        the connection using a <a href="#type-close">close</a> frame with an error explaining why.
        There is no requirement for peers to support arbitrarily short or long idle timeouts.
      </p><p>
        The use of idle timeouts is in addition to any network protocol level control.
        Implementations SHOULD make use of TCP keep-alive wherever possible in order to be good
        citizens.
      </p><p>
        If a peer needs to satisfy the need to send traffic to prevent idle timeout, and has
        nothing to send, it MAY send an empty frame, i.e., a frame consisting solely of a frame
        header, with no frame body. Implementations MUST be prepared to handle empty frames
        arriving on any valid channel, though implementations SHOULD use channel 0 when sending
        empty frames, and MUST use channel 0 if a maximum channel number has not yet been negotiated
        (i.e., before an <a href="#type-open">open</a> frame has been received). Apart from this use, empty
        frames have no meaning.
       </p><p>
         Empty frames can only be sent after the <a href="#type-open">open</a> frame is sent. As
         they are a frame, they MUST NOT be sent after the <a href="#type-close">close</a> frame
         has been sent.
       </p><p>
         As an alternative to using an empty frame to prevent an idle timeout, if a connection
         is in a permissible state, an implementation MAY choose to send a flow frame for a valid
         session.
       </p><p>
         If during operation a peer exceeds the remote peer's idle timeout's threshold, e.g.,
         because it is heavily loaded, it SHOULD gracefully close the connection by using a
         <a href="#type-close">close</a> frame with an error explaining why.
       </p></div><h3><a class="toc" href="#toc">←</a>2.4.6 <a name="doc-idp184736">Connection States</a></h3><div class="doc"><dl>
        <dt>START</dt>
        <dd><p>In this state a connection exists, but nothing has been sent or received. This is the
            state an implementation would be in immediately after performing a socket connect or
            socket accept.</p></dd>

        <dt>HDR_RCVD</dt>
        <dd><p>In this state the connection header has been received from the peer but a connection
            header has not been sent.</p></dd>

        <dt>HDR_SENT</dt>
        <dd><p>In this state the connection header has been sent to the peer but no connection
            header has been received.</p></dd>

        <dt>HDR_EXCH</dt>
        <dd><p>In this state the connection header has been sent to the peer and a connection header
            has been received from the peer.</p></dd>

        <dt>OPEN_PIPE</dt>
        <dd><p>In this state both the connection header and the <a href="#type-open">open</a>
            frame have been sent but nothing has been received.
            </p></dd>

        <dt>OC_PIPE</dt>
        <dd><p>In this state, the connection header, the <a href="#type-open">open</a> frame, any
            pipelined connection traffic, and the <a href="#type-close">close</a> frame have been
            sent but nothing has been received.</p></dd>

        <dt>OPEN_RCVD</dt>
        <dd><p>In this state the connection headers have been exchanged. An <a href="#type-open">open</a> frame has been received from the peer but an <a href="#type-open">open</a> frame has not been sent.</p></dd>

        <dt>OPEN_SENT</dt>
        <dd><p>In this state the connection headers have been exchanged. An <a href="#type-open">open</a> frame has been sent to the peer but no <a href="#type-open">open</a> frame has yet been received.</p></dd>

        <dt>CLOSE_PIPE</dt>
        <dd><p>In this state the connection headers have been exchanged. An <a href="#type-open">open</a> frame, any pipelined connection traffic, and the <a href="#type-close">close</a> frame have been sent but no <a href="#type-open">open</a> frame has
            yet been received from the peer.</p></dd>

        <dt>OPENED</dt>
        <dd><p>In this state the connection header and the <a href="#type-open">open</a> frame
            have been both sent and received.</p></dd>

        <dt>CLOSE_RCVD</dt>
        <dd><p>In this state a <a href="#type-close">close</a> frame has been received indicating
            that the peer has initiated an AMQP close. No further frames are expected to arrive on
            the connection; however, frames can still be sent. If desired, an implementation MAY do
            a TCP half-close at this point to shut down the read side of the connection.</p></dd>

        <dt>CLOSE_SENT</dt>
        <dd><p>In this state a <a href="#type-close">close</a> frame has been sent to the peer.
            It is illegal to write anything more onto the connection, however there could
            potentially still be incoming frames. If desired, an implementation MAY do a TCP
            half-close at this point to shutdown the write side of the connection.</p></dd>

        <dt>DISCARDING</dt>
        <dd><p>The DISCARDING state is a variant of the CLOSE_SENT state where the
            <a href="#type-close">close</a> is triggered by an error. In this case any incoming frames on
            the connection MUST be silently discarded until the peer's <a href="#type-close">close</a> frame
            is received.</p></dd>

        <dt>END</dt>
        <dd><p>In this state it is illegal for either endpoint to write anything more onto the
            connection. The connection can be safely closed and discarded.</p></dd>
      </dl></div><h3><a class="toc" href="#toc">←</a>2.4.7 <a name="doc-idp211568">Connection State Diagram</a></h3><div class="doc"><p>
        The graph below depicts a complete state diagram for each endpoint. The boxes represent
        states, and the arrows represent state transitions. Each arrow is labeled with the action
        that triggers that particular transition.
      </p><table class="pre" summary="Connection State Diagram"><caption style="caption-side:bottom">Figure 2.23: Connection State Diagram</caption><tr><td>
             R:HDR @=======@ S:HDR             R:HDR[!=S:HDR]
          +--------| START |-----+    +--------------------------------+
          |        @=======@     |    |                                |
         \|/                    \|/   |                                |
     @==========@             @==========@ S:OPEN                      |
+----| HDR_RCVD |             | HDR_SENT |------+                      |
|    @==========@             @==========@      |      R:HDR[!=S:HDR]  |
|   S:HDR |                      | R:HDR        |    +-----------------+
|         +--------+      +------+              |    |                 |
|                 \|/    \|/                   \|/   |                 |
|                @==========@               +-----------+ S:CLOSE      |
|                | HDR_EXCH |               | OPEN_PIPE |----+         |
|                @==========@               +-----------+    |         |
|           R:OPEN |      | S:OPEN              | R:HDR      |         |
|         +--------+      +------+      +-------+            |         |
|        \|/                    \|/    \|/                  \|/        |
|   @===========@             @===========@ S:CLOSE       +---------+  |
|   | OPEN_RCVD |             | OPEN_SENT |-----+         | OC_PIPE |--+
|   @===========@             @===========@     |         +---------+  |
|  S:OPEN |                      | R:OPEN      \|/           | R:HDR   |
|         |       @========@     |          +------------+   |         |
|         +------&gt;| OPENED |&lt;----+          | CLOSE_PIPE |&lt;--+         |
|                 @========@                +------------+             |
|           R:CLOSE |    | S:CLOSE              | R:OPEN               |
|         +---------+    +-------+              |                      |
|        \|/                    \|/             |                      |
|   @============@          @=============@     |                      |
|   | CLOSE_RCVD |          | CLOSE_SENT* |&lt;----+                      |
|   @============@          @=============@                            |
| S:CLOSE |                      | R:CLOSE                             |
|         |         @=====@      |                                     |
|         +--------&gt;| END |&lt;-----+                                     |
|                   @=====@                                            |
|                     /|\                                              |
|    S:HDR[!=R:HDR]    |                R:HDR[!=S:HDR]                 |
+----------------------+-----------------------------------------------+

                     R:&lt;CTRL&gt; = Received &lt;CTRL&gt;
                     S:&lt;CTRL&gt; = Sent &lt;CTRL&gt;
                     * Also could be DISCARDING if an error condition
                       triggered the CLOSE 
      </td></tr></table><table class="pre" summary="Connection State Table"><caption style="caption-side:bottom">Figure 2.24: Connection State Table</caption><tr><td>
State        Legal Sends     Legal Receives    Legal Connection Actions
=======================================================================
START        HDR             HDR
HDR_RCVD     HDR             OPEN
HDR_SENT     OPEN            HDR
HDR_EXCH     OPEN            OPEN
OPEN_RCVD    OPEN            *
OPEN_SENT    **              OPEN
OPEN_PIPE    **              HDR
CLOSE_PIPE   -               OPEN              TCP Close for Write
OC_PIPE      -               HDR               TCP Close for Write
OPENED       *               *
CLOSE_RCVD   *               -                 TCP Close for Read
CLOSE_SENT   -               *                 TCP Close for Write
DISCARDING   -               *                 TCP Close for Write
END          -               -                 TCP Close

*  = any frames
-  = no frames
** = any frame known a priori to conform to the
     peer's capabilities and limitations 
      </td></tr></table></div></div>

  

  <h2><a class="toc" href="#toc">←</a>2.5 <a name="section-sessions">Sessions</a></h2><div class="section"><div class="doc"><p>
        A session is a bidirectional sequential conversation between two containers that provides a
        grouping for related links. Sessions serve as the context for link communication. Any number
        of links of any directionality can be <i>attached</i> to a given session. However, a link
        MUST NOT be attached to more than one session at a time.
      </p><table class="pre" summary="Instance Diagram of Session/Link attachment"><caption style="caption-side:bottom">Figure 2.25: Instance Diagram of Session/Link attachment</caption><tr><td>
Link A-------+                          +------&gt;Link A
             |                          |
            \|/       (attached)        |
Link B&lt;--- Session &lt;--------------&gt; Session &lt;---Link B


Link C------&gt;*        (detached)        *------&gt;Link C 
      </td></tr></table><p>
        Messages transferred on a link are sequentially identified within the session. A session can
        be viewed as multiplexing link traffic, much like a connection multiplexes session traffic.
        However, unlike the sessions on a connection, links on a session are not entirely
        independent since they share a common delivery sequence scoped to the session. This common
        sequence allows endpoints to efficiently refer to sets of deliveries regardless of the
        originating link. This is of particular benefit when a single application is receiving
        messages along a large number of different links. In this case the session
        provides <i>aggregation</i> of otherwise independent links into a single stream that can be
        efficiently acknowledged by the receiving application.
      </p></div><h3><a class="toc" href="#toc">←</a>2.5.1 <a name="doc-idp223280">Establishing A Session</a></h3><div class="doc"><p>
        Sessions are established by creating a session endpoint, assigning it to an unused channel
        number, and sending a <a href="#type-begin">begin</a> announcing the association of the
        session endpoint with the outgoing channel. Upon receiving the <a href="#type-begin">begin</a> the partner will check the remote-channel field and find it empty. This
        indicates that the begin is referring to remotely initiated session. The partner will
        therefore allocate an unused outgoing channel for the remotely initiated session and
        indicate this by sending its own <a href="#type-begin">begin</a> setting the
        remote-channel field to the incoming channel of the remotely initiated session.
      </p><p>
        To make it easier to monitor AMQP sessions, it is RECOMMENDED that implementations always
        assign the lowest available unused channel number.
      </p><p>
        The remote-channel field of a <a href="#type-begin">begin</a> frame MUST be empty for a
        locally initiated session, and MUST be set when announcing the endpoint created as a result
        of a remotely initiated session.
      </p><table class="pre" summary="Session Begin Sequence"><caption style="caption-side:bottom">Figure 2.26: Session Begin Sequence</caption><tr><td>
    Endpoint                                      Endpoint
    =====================================================================
    [CH3] BEGIN(name=...,        ---------&gt;
                remote-channel=null)
                                        +-- [CH7] BEGIN(name=...,
                                       /                remote-channel=3)
                                      /
                                 &lt;---+

                                    ...

    --------------------------------------------------------------------- 
      </td></tr></table></div><h3><a class="toc" href="#toc">←</a>2.5.2 <a name="doc-idp230944">Ending A Session</a></h3><div class="doc"><p>
        Sessions end automatically when the connection is closed or interrupted. Sessions are
        explicitly ended when either endpoint chooses to end the session. When a session is
        explicitly ended, an <a href="#type-end">end</a> frame is sent to announce the
        disassociation of the endpoint from its outgoing channel, and to carry error information
        when relevant.
      </p><table class="pre" summary="Session End Sequence"><caption style="caption-side:bottom">Figure 2.27: Session End Sequence</caption><tr><td>
    Endpoint A                              Endpoint B
    ====================================================================

                                     ...

    [CH3] END(error=...)         ---------&gt;                          (1)
                                        +-- [CH7] END(error=...)
                                       /
                                      /
(2)                              &lt;---+

                                     ...

    --------------------------------------------------------------------

      (1) At this point the session endpoint is disassociated from
          the outgoing channel on A, and the incoming channel on B.

      (2) At this point the session endpoint is disassociated from
          the outgoing channel on B, and the incoming channel on A.  
      </td></tr></table></div><h3><a class="toc" href="#toc">←</a>2.5.3 <a name="doc-idp235408">Simultaneous End</a></h3><div class="doc"><p>
        Due to the potentially asynchronous nature of sessions, it is possible that both peers
        simultaneously decide to end a session. If this happens, it will appear to each peer
        as though their partner's spontaneously initiated <a href="#type-end">end</a> frame is
        actually an answer to the peers initial <a href="#type-end">end</a> frame.
      </p><table class="pre" summary="Simultaneous Session End Sequence"><caption style="caption-side:bottom">Figure 2.28: Simultaneous Session End Sequence</caption><tr><td>
    Endpoint A                            Endpoint B
    =================================================================

                                   ...

    [CH3] END(error=...)        --+   +-- [CH7] END(error=...)
(1)                                \ /                                (2)
                                    x
                                   / \
(3)                             &lt;-+   +-&gt;                             (4)

                                   ...

    -----------------------------------------------------------------

      (1) At this point no more frames can be sent by A.

      (2) At this point no more frames can be sent by B.

      (3) At this point endpoint A is fully ended.

      (4) At this point endpoint B is fully ended.  
      </td></tr></table></div><h3><a class="toc" href="#toc">←</a>2.5.4 <a name="doc-idp239696">Session Errors</a></h3><div class="doc"><p>
        When a session is unable to process input, it MUST indicate this by issuing an END with an
        appropriate <a href="#type-error">error</a> indicating the cause of the problem. It MUST then proceed
        to discard all incoming frames from the remote endpoint until receiving the remote
        endpoint's corresponding <a href="#type-end">end</a> frame.
      </p><table class="pre" summary="Session Error Sequence"><caption style="caption-side:bottom">Figure 2.29: Session Error Sequence</caption><tr><td>
Endpoint                      Endpoint
================================================
FRAME 1           ----------&gt;
FRAME 2           ----------&gt;
FRAME 3           ---+   +--- END(error=...)
                      \ /
                       x
                      / \
                  &lt;--+   +--&gt; *discarded*
END               ----------&gt;
                      ...
================================================ 
      </td></tr></table></div><h3><a class="toc" href="#toc">←</a>2.5.5 <a name="doc-idp243424">Session States</a></h3><div class="doc"><dl>
        <dt>UNMAPPED</dt>
        <dd><p>In the UNMAPPED state, the session endpoint is not mapped to any incoming or outgoing
            channels on the connection endpoint. In this state an endpoint cannot send or receive
            frames.</p></dd>

        <dt>BEGIN_SENT</dt>
        <dd><p>In the BEGIN_SENT state, the session endpoint is assigned an outgoing channel number,
            but there is no entry in the incoming channel map. In this state the endpoint MAY send
            frames but cannot receive them.</p></dd>

        <dt>BEGIN_RCVD</dt>
        <dd><p>In the BEGIN_RCVD state, the session endpoint has an entry in the incoming channel
            map, but has not yet been assigned an outgoing channel number. The endpoint MAY receive
            frames, but cannot send them.</p></dd>

        <dt>MAPPED</dt>
        <dd><p>In the MAPPED state, the session endpoint has both an outgoing channel number and an
            entry in the incoming channel map. The endpoint MAY both send and receive
            frames.</p></dd>

        <dt>END_SENT</dt>
        <dd><p>In the END_SENT state, the session endpoint has an entry in the incoming channel map,
            but is no longer assigned an outgoing channel number. The endpoint MAY receive frames,
            but cannot send them.</p></dd>

        <dt>END_RCVD</dt>
        <dd><p>In the END_RCVD state, the session endpoint is assigned an outgoing channel number,
            but there is no entry in the incoming channel map. The endpoint MAY send frames, but
            cannot receive them.</p></dd>

        <dt>DISCARDING</dt>
        <dd><p>The DISCARDING state is a variant of the END_SENT state where the <a href="#type-end">end</a>
            is triggered by an error. In this case any incoming frames on the session MUST be
            silently discarded until the peer's <a href="#type-end">end</a> frame is received.</p></dd>
      </dl><table class="pre" summary="State Transitions"><caption style="caption-side:bottom">Figure 2.30: State Transitions</caption><tr><td>
                        UNMAPPED&lt;-------------------+
                           |                        |
                   +-------+-------+                |
           S:BEGIN |               | R:BEGIN        |
                   |               |                |
                  \|/             \|/               |
               BEGIN_SENT      BEGIN_RCVD           |
                   |               |                |
                   |               |                |
           R:BEGIN |               | S:BEGIN        |
                   +-------+-------+                |
                           |                        |
                          \|/                       |
                         MAPPED                     |
                           |                        |
             +-------------+-------------+          |
S:END(error) |       S:END |             | R:END    |
             |             |             |          |
            \|/           \|/           \|/         |
         DISCARDING     END_SENT      END_RCVD      |
             |             |             |          |
             |             |             |          |
       R:END |       R:END |             | S:END    |
             +-------------+-------------+          |
                           |                        |
                           |                        |
                           +------------------------+ 
      </td></tr></table><p>
        There is no obligation to retain a session endpoint after it transitions to the UNMAPPED
        state.
      </p></div><h3><a class="toc" href="#toc">←</a>2.5.6 <a name="doc-session-flow-control">Session Flow Control</a></h3><div class="doc"><p>
        The session endpoint assigns each outgoing <a href="#type-transfer">transfer</a> frame an implicit
        <i>transfer-id</i> from a session scoped sequence. Each session endpoint maintains the
        following state to manage incoming and outgoing <a href="#type-transfer">transfer</a> frames:
      </p><dl>
        <dt>next-incoming-id</dt>
        <dd><p>The <i>next-incoming-id</i> identifies the expected transfer-id of the next incoming
            <a href="#type-transfer">transfer</a> frame.</p></dd>

        <dt>incoming-window</dt>
        <dd><p>The <i>incoming-window</i> defines the maximum number of incoming
            <a href="#type-transfer">transfer</a> frames that the endpoint can currently receive. This identifies
            a current maximum incoming transfer-id that can be computed by subtracting one from the
            sum of <i>incoming-window</i> and <i>next-incoming-id</i>.</p></dd>

        <dt>next-outgoing-id</dt>
        <dd><p>The <i>next-outgoing-id</i> is the transfer-id to assign to the next transfer frame.
            The <i>next-outgoing-id</i> MAY be initialized to an arbitrary value and is incremented
            after each successive <a href="#type-transfer">transfer</a> according to RFC-1982 [<a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-overview-v1.0-os.html#anchor-RFC1982">RFC1982</a>] serial number arithmetic.</p></dd>

        <dt>outgoing-window</dt>
        <dd><p>The <i>outgoing-window</i> defines the maximum number of outgoing
            <a href="#type-transfer">transfer</a> frames that the endpoint can currently send. This identifies a
            current maximum outgoing transfer-id that can be computed by subtracting one from the
            sum of <i>outgoing-window</i> and <i>next-outgoing-id</i>.</p></dd>

        <dt>remote-incoming-window</dt>
        <dd><p>The <i>remote-incoming-window</i> reflects the maximum number of outgoing transfers
          that can be sent without exceeding the remote endpoint's incoming-window. This value MUST
          be decremented after every <a href="#type-transfer">transfer</a> frame is sent, and recomputed when
          informed of the remote session endpoint state.</p></dd>

        <dt>remote-outgoing-window</dt>
        <dd><p>The <i>remote-outgoing-window</i> reflects the maximum number of incoming transfers
          that MAY arrive without exceeding the remote endpoint's outgoing-window. This value MUST
          be decremented after every incoming <a href="#type-transfer">transfer</a> frame is received, and
          recomputed when informed of the remote session endpoint state. When this window shrinks,
          it is an indication of outstanding transfers. Settling outstanding transfers can cause the
          window to grow.</p></dd>
      </dl><p>
        Once initialized, this state is updated by various events that occur in the lifespan of a
        session and its associated links:
      </p><dl>
        <dt>sending a transfer</dt>
        <dd><p>Upon sending a transfer, the sending endpoint will increment its next-outgoing-id,
            decrement its remote-incoming-window, and MAY (depending on policy) decrement its
            outgoing-window.</p></dd>

        <dt>receiving a transfer</dt>
        <dd><p>Upon receiving a transfer, the receiving endpoint will increment the next-incoming-id
            to match the implicit transfer-id of the incoming transfer plus one, as well as
            decrementing the remote-outgoing-window, and MAY (depending on policy) decrement its
            incoming-window.</p></dd>

        <dt>receiving a flow</dt>
        <dd><p>When the endpoint receives a <a href="#type-flow">flow</a> frame from its peer, it MUST update
            the <i>next-incoming-id</i> directly from the <i>next-outgoing-id</i> of the frame, and
            it MUST update the <i>remote-outgoing-window</i> directly from the
            <i>outgoing-window</i> of the frame.</p>

          <p>
            The <i>remote-incoming-window</i> is computed as follows:
          </p>

          <p>
            <i>next-incoming-id<sub>flow</sub></i> + <i>incoming-window<sub>flow</sub></i>
            - <i>next-outgoing-id<sub>endpoint</sub></i>
          </p>

          <p>
            If the <i>next-incoming-id</i> field of the <a href="#type-flow">flow</a> frame is not set,
            then <i>remote-incoming-window</i> is computed as follows:
          </p>

          <p>
            <i>initial-outgoing-id<sub>endpoint</sub></i> + <i>incoming-window<sub>flow</sub></i>
            - <i>next-outgoing-id<sub>endpoint</sub></i>
          </p>
        </dd>
      </dl></div></div>

  

  <h2><a class="toc" href="#toc">←</a>2.6 <a name="section-links">Links</a></h2><div class="section"><div class="doc"><p>
        A link provides a unidirectional transport for messages between a source and a target. The
        primary responsibility of a source or target (a terminus) is to maintain a record of the
        status of each active delivery attempt until such a time as it is safe to forget. These are
        referred to as <i>unsettled</i> deliveries. When a terminus forgets the state
        associated with a delivery-tag, it is considered <i>settled</i>. Settling a delivery
        at a terminus is an idempotent idempotent, i.e., a delivery can transition from unsettled to
        settled, but never the reverse. Each delivery attempt is assigned a unique
        <i>delivery-tag</i> at the source. The status of an active delivery attempt is known
        as the <i>delivery state</i> of the delivery.
      </p><p>
        Link endpoints interface between a terminus and a session endpoint, and maintain additional
        state used for active communication between the local and remote endpoints. Therefore there
        are two types of endpoint: <i>senders</i> and <i>receivers</i>. When the
        sending application submits a message to the sender for transport, it also supplies the
        delivery-tag used by the source to track the delivery state. The link endpoint assigns each
        message a unique <i>delivery-id</i> from a session scoped sequence. These delivery-ids
        are used to efficiently reference subsets of the outstanding deliveries on a session.
      </p><p>
        Termini can exist beyond their associated link endpoints, so it is possible for a session to
        terminate and the termini to remain. A link is said to be <i>suspended</i> if the
        termini exist, but have no associated link endpoints. The process of associating new link
        endpoints with existing termini and re-establishing communication is referred to
        as <i>resuming</i> a link.
      </p><p>
        The original link endpoint state is not necessary for resumption of a link. Only the
        unsettled delivery state maintained at the termini is necessary for link resume, and this
        need not be stored directly. The form of delivery-tags is intentionally left open-ended so
        that they and their related delivery state can, if desired, be (re)constructed from
        application state, thereby minimizing or eliminating the need to retain additional
        protocol-specific state in order to resume a link.
      </p></div><h3><a class="toc" href="#toc">←</a>2.6.1 <a name="doc-idp298752">Naming A Link</a></h3><div class="doc"><p>
        Links are named so that they can be recovered when communication is interrupted. Link names
        MUST uniquely identify the link amongst all links of the same direction between the two
        participating containers. Link names are only used when attaching a link, so they can be
        arbitrarily long without a significant penalty.
      </p><p>
        A link's name uniquely identifies the link from the container of the source to the
        container of the target node, i.e., if the container of the source node is A, and the
        container of the target node is B, the link can be globally identified by the (ordered)
        tuple <i>(A,B,&lt;name&gt;)</i>. Consequently, a link can only be active in one connection
        at a time. If an attempt is made to attach the link subsequently when it is not suspended,
        then the link can be 'stolen', i.e., the second attach succeeds and the first attach MUST
        then be closed with a link error of <a href="#choice-link-error-stolen">stolen</a>. This behavior
        ensures that in the event of a connection failure occurring and being noticed by one party,
        that re-establishment has the desired effect.
      </p></div><h3><a class="toc" href="#toc">←</a>2.6.2 <a name="doc-link-handles">Link Handles</a></h3><div class="doc"><p>
        Each link endpoint is assigned a numeric handle used by the peer as a shorthand to refer to
        the link in all frames that reference the link (<a href="#type-attach">attach</a>,
        <a href="#type-detach">detach</a>, <a href="#type-flow">flow</a>, <a href="#type-transfer">transfer</a>, <a href="#type-disposition">disposition</a>). This handle is assigned by the
        initial <a href="#type-attach">attach</a> frame and remains in use until the link is
        detached. The two endpoints are not REQUIRED to use the same handle. This means a peer is
        free to independently chose its handle when a link endpoint is associated with the session.
        The locally chosen handle is referred to as the <i>output handle</i>. The remotely
        chosen handle is referred to as the <i>input handle</i>.
      </p><p>
        At an endpoint, a link is considered to be <i>attached</i> when the link endpoint
        exists and has both input and output handles assigned at an active session endpoint. A link
        is considered to be <i>detached</i> when the link endpoint exists, but is not assigned
        either input or output handles. A link can be considered <i>half attached</i>
        (or <i>half detached</i>) when only one of the input or output handles is assigned.
      </p><table class="pre" summary="Link Handles"><caption style="caption-side:bottom">Figure 2.31: Link Handles</caption><tr><td>
+-------------------+                             +-------------------+
|    name: Link_1   |                             |    name: Link_1   |
|  handle: i        |                             |  handle: j        |
|-------------------|                             |-------------------|
|    role: receiver |                             |    role: sender   |
|  source: A        |&lt;---+                   +---&gt;|  source: A        |
|  target: B        |    |                   |    |  target: B        |
+-------------------+    |                   |    +-------------------+
                         |                   |
                         |    +---------+    |
        ...          &lt;---+---&gt;| Session |&lt;---+---&gt;        ...
                         |    +---------+    |
                         |                   |
+-------------------+    |                   |    +-------------------+
|    name: Link_N   |    |                   |    |    name: Link_N   |
|  handle: k        |&lt;---+                   +---&gt;|  handle: l        |
|-------------------|                             |-------------------|
|    role: sender   |                             |    role: receiver |
|  source: C        |                             |  source: C        |
|  target: D        |                             |  target: D        |
+-------------------+                             +-------------------+ 
      </td></tr></table></div><h3><a class="toc" href="#toc">←</a>2.6.3 <a name="doc-idp315568">Establishing Or Resuming A Link</a></h3><div class="doc"><p>
        Links are established and/or resumed by creating a link endpoint associated with a local
        terminus, assigning it to an unused handle, and sending an <a href="#type-attach">attach</a>
        frame. This frame carries the state of the newly created link endpoint, including the local
        and remote termini, one being the source and one being the target depending on the
        directionality of the link endpoint. On receipt of the <a href="#type-attach">attach</a>, the remote
        session endpoint creates a corresponding link endpoint and informs its application of the
        attaching link. The application attempts to locate the terminus previously associated with
        the link. This terminus is associated with the link endpoint and can be updated if its
        properties do not match those sent by the remote link endpoint. If no such terminus exists,
        the application MAY choose to create one using the properties supplied by the remote link
        endpoint. The link endpoint is then mapped to an unused handle, and an <a href="#type-attach">attach</a> frame is issued carrying the state of the newly created endpoint. Note that
        if the application chooses not to create a terminus, the session endpoint will still create
        a link endpoint and issue an <a href="#type-attach">attach</a> indicating that the link
        endpoint has no associated local terminus. In this case, the session endpoint MUST
        immediately detach the newly created link endpoint.
      </p><table class="pre" summary="Establishing a Link"><caption style="caption-side:bottom">Figure 2.32: Establishing a Link</caption><tr><td>
Peer                                  Partner
================================================================
*create link endpoint*
ATTACH(name=N, handle=1,    ----------&gt; *create link endpoint*
       role=sender,                +--- ATTACH(name=N, handle=2,
       source=A,                  /            role=receiver,
       target=B)                 /             source=A,
                                /              target=B)
                            &lt;--+
                              ...
---------------------------------------------------------------- 
      </td></tr></table><p>
        If there is no pre-existing terminus, and the peer does not wish to create a new one, this
        is indicated by setting the local terminus (source or target as appropriate) to null.
      </p><table class="pre" summary="Refusing a Link"><caption style="caption-side:bottom">Figure 2.33: Refusing a Link</caption><tr><td>
    Peer                                  Partner
    ================================================================
    *create link endpoint*
    ATTACH(name=N, handle=1,    ----------&gt; *create link endpoint*  (1)
           role=sender,                +--- ATTACH(name=N, handle=2,
           source=A,                  /            role=receiver,
           target=B)                 /             source=A,
                                    /              target=-)
(2)                             &lt;--+
                                       +--- DETACH(handle=2,
                                      /            closed=True)
                                     /
                                    /
                                &lt;--+
    DETACH(handle=1,            -----------&gt;
           closed=True)
                                  ...
    ----------------------------------------------------------------
      (1) The link endpoint is created, but no target is created.
      (2) At this point the link is established, but it is to a
          nonexistent target.  
      </td></tr></table><p>
        If either end of the link is already associated with a terminus, the <a href="#type-attach">attach</a>
        frame MUST include its unsettled delivery state.
      </p><table class="pre" summary="Resuming a Link"><caption style="caption-side:bottom">Figure 2.34: Resuming a Link</caption><tr><td>
    Peer                                   Partner
    ================================================================
    *existing source*
    ATTACH(name=N, handle=1,   ----------&gt; *found existing target*
           role=sender,               +--- ATTACH(name=N, handle=2,  (1)
           source=X,                 /            role=receiver,
           target=Y,                /             source=X,
           unsettled=...)          /              target=Y,
(2)                            &lt;--+               unsettled=...)
                                   ...
    ----------------------------------------------------------------
      (1) The target already exists, and its properties
          match the peer's expectations.
      (2) At this point the link is reestablished with source=X,
          target=Y.  
      </td></tr></table><p>
        Note that it is possible that the expected terminus properties do not match the actual
        terminus properties reported by the remote endpoint. In this case, the link is always
        considered to be between the source as described by the sender, and the target as described
        by the receiver. This can happen both when establishing and when resuming a link.
      </p><p>
        When a link is established, it is possible for an endpoint not to have all the capabilities
        necessary to create the terminus exactly matching the expectations of the peer. If this
        happens, the endpoint MAY adjust the properties in order to succeed in creating the
        terminus. In this case the endpoint MUST report the actual properties of the terminus as
        created.
      </p><p>
        When resuming a link, it is possible that the properties of the source and target have
        changed while the link was suspended. When this happens, the termini properties
        communicated in the source and target fields of the <a href="#type-attach">attach</a> frames could be
        in conflict. In this case, the sender is considered to hold the authoritative version of
        the source properties, the receiver is considered to hold the authoritative version of the
        target properties. As above, the resulting link is constructed to be between the source
        as described by the sender, and the target as described by the receiver. Once the link is
        resumed, either peer is free to continue if the updated properties are acceptable, or, if
        not, <a href="#type-detach">detach</a> the link.
      </p><p>
        Note that a peer MUST take responsibility for verifying that the remote terminus meets its
        requirements. The remote peer SHOULD NOT attempt to preempt whether the terminus will meet
        the requirements of its partner. This is equally true both for creating and resuming links.
      </p><table class="pre" summary="Resuming an altered Link"><caption style="caption-side:bottom">Figure 2.35: Resuming an altered Link</caption><tr><td>
    Peer                                 Partner
    ================================================================
    *existing source*
    ATTACH(name=N, handle=1,   ----------&gt; *found existing target*
           role=sender,               +--- ATTACH(name=N, handle=2,  (1)
           source=A,                 /            role=receiver,
           target=B,                /             source=A,
           unsettled=...)          /              target=C,
(2)                            &lt;--+               unsettled=...)
                                   ...
    ----------------------------------------------------------------
      (1) The terminus already exists, but its state
          does not match the peer's endpoint.
      (2) At this point the link is established with source=A,
          target=C.  
      </td></tr></table><p>
        It is possible to resume a link even if one of the termini has lost nearly all its state.
        All that is necessary is the link name and direction. This is referred to as
        <i>recovering</i> a link. This is done by creating a new link endpoint with an empty
        source or target for incoming or outgoing links respectively. The full link state is then
        constructed from the authoritative source or target supplied by the other endpoint once the
        link is established. If the remote peer has no record of the link, then no terminus will be
        located, and local terminus (source or target as appropriate) field in the
        <a href="#type-attach">attach</a> frame will be null.
      </p><table class="pre" summary="Recovering a Link"><caption style="caption-side:bottom">Figure 2.36: Recovering a Link</caption><tr><td>
    Peer                                   Partner
    ================================================================
    *create link endpoint*
    ATTACH(name=N, handle=1,   ----------&gt; *found existing target*
           role=sender,               +--- ATTACH(name=N, handle=2,  (1)
           source=X                  /            role=receiver,
           target=-)                /             source=X,
(2)                            &lt;---+              target=Y)
                                   ...
    ----------------------------------------------------------------
      (1) The target already exists, and its properties are
          authoritative.
      (2) At this point the link is reestablished with source=X,
          target=Y.  
      </td></tr></table></div><h3><a class="toc" href="#toc">←</a>2.6.4 <a name="doc-idp339696">Detaching And Reattaching A Link</a></h3><div class="doc"><p>
        A session endpoint can choose to unmap its output handle for a link. In this case, the
        endpoint MUST send a <a href="#type-detach">detach</a> frame to inform the remote peer that the handle
        is no longer attached to the link endpoint. If both endpoints do this, the link MAY
        return to a fully detached state. Note that in this case the link endpoints MAY still
        indirectly communicate via the session, as there could still be active deliveries on the
        link referenced via delivery-id.
      </p><table class="pre" summary="Detaching a Link"><caption style="caption-side:bottom">Figure 2.37: Detaching a Link</caption><tr><td>
    Peer                                Partner
    =============================================================
    *create link endpoint*
    ATTACH(name=N, handle=1   ----------&gt; *create link endpoint*
           role=sender,              +--- ATTACH(name=N, handle=2,
           source=A,                /            role=receiver,
           target=B)               /             source=A,
                                  /              target=B)
                              &lt;--+
                                  ...
    *use link*                &lt;---------&gt; *use link*
                                  ...
    DETACH(handle=1)          ----------&gt; *detach input handle*
(1) *detach output handle*    &lt;---------- DETACH(handle=2)
                                  ...
    -------------------------------------------------------------
      (1) At this point both endpoints are detached.  
      </td></tr></table><p>
        When the state of a link endpoint changes, this is can be communicated by detaching and then
        reattaching with the updated state on the <a href="#type-attach">attach</a> frame. This can be used to
        update the properties of the link endpoints, or to update the properties of the termini.
      </p><table class="pre" summary="Updating Link State"><caption style="caption-side:bottom">Figure 2.38: Updating Link State</caption><tr><td>
    Peer                                Partner
    =============================================================
                                  ...
    DETACH(handle=1)          ---+
                                  \
                                   \
                                    \
    *modify link endpoint*           \
                                      +--&gt; *detach input handle*
    ATTACH(name=N, handle=1   ---+    +--- DETACH(handle=2)
           role=sender,           \  /
           source=A',              \/
           target=B')              /\
                                  /  \
     *detach input handle*    &lt;--+    +--&gt; *reattach input handle*
                                           *modify link endpoint*
                                      +--- ATTACH(name=N, handle=2
                                     /            role=receiver,
                                    /             source=A',
                                   /              target=B')
                                  /
(1)  *reattach input handle*  &lt;--+
                                  ...
    *use link*               &lt;---------&gt; *use link*
                                  ...
    -------------------------------------------------------------
      (1) At this point the link is updated and attached.  
      </td></tr></table></div><h3><a class="toc" href="#toc">←</a>2.6.5 <a name="doc-idp348080">Link Errors</a></h3><div class="doc"><p>
        When an error occurs at a link endpoint, the endpoint MUST be detached with appropriate
        error information supplied in the error field of the <a href="#type-detach">detach</a> frame. The link
        endpoint MUST then be destroyed. If any input (other than a detach) related to the
        endpoint either via the input handle or delivery-ids be received, the session MUST be
        terminated with an <a href="#choice-session-error-errant-link">errant-link</a> session-error. Since
        the link endpoint has been destroyed, the peer cannot reattach, and MUST resume the link in
        order to restore communication. In order to disambiguate the resume request from a pipelined
        re-attach the resuming <a href="#type-attach">attach</a> performative MUST contain a non-null value for
        its unsettled field. Receipt of a pipelined <a href="#type-attach">attach</a> MUST result in the session
        being terminated with an <a href="#choice-session-error-errant-link">errant-link</a> session-error.
      </p></div><h3><a class="toc" href="#toc">←</a>2.6.6 <a name="doc-closing-a-link">Closing A Link</a></h3><div class="doc"><p>
        A peer closes a link by sending the <a href="#type-detach">detach</a> frame with the handle
        for the specified link, and the closed flag set to true. The partner will destroy the
        corresponding link endpoint, and reply with its own <a href="#type-detach">detach</a> frame
        with the closed flag set to true.
      </p><table class="pre" summary="Closing a Link"><caption style="caption-side:bottom">Figure 2.39: Closing a Link</caption><tr><td>
    Peer                                Partner
    =============================================================
    *create link endpoint*
    ATTACH(name=N, handle=1   ----------&gt; *create link endpoint*
           role=sender,              +--- ATTACH(name=N, handle=2,
           source=A,                /            role=receiver,
           target=B)               /             source=A,
                                  /              target=B)
                              &lt;--+
                                  ...
    *use link*                &lt;---------&gt; *use link*
                                  ...
    DETACH(handle=1,          ----------&gt; *destroy link endpoint*
           closed=True)
(1) *destroy link endpoint*   &lt;---------- DETACH(handle=2,
                                                 closed=True)
    -------------------------------------------------------------
      (1) At this point both endpoints are destroyed.  
      </td></tr></table><p>
        Note that one peer MAY send a closing detach while its partner is sending a non-closing
        detach. In this case, the partner MUST signal that it has closed the link by reattaching and
        then sending a closing detach.
      </p></div><h3><a class="toc" href="#toc">←</a>2.6.7 <a name="doc-flow-control">Flow Control</a></h3><div class="doc"><p>
        Once attached, a link is subject to flow control of message transfers. Link endpoints
        maintain the following flow control state. This state defines when it is legal to send
        transfers on an attached link, as well as indicating when certain interesting conditions
        occur, such as insufficient messages to consume the currently available <i>link-credit</i>,
        or insufficient <i>link-credit</i> to send available messages:
      </p><dl>
        <dt>delivery-count</dt>
        <dd><p>The <i>delivery-count</i> is initialized by the sender when a link endpoint is
            created, and is incremented whenever a message is sent. Only the sender MAY
            independently modify this field. The receiver's value is calculated based on the last
            known value from the sender and any subsequent messages received on the link. Note that,
            despite its name, the delivery-count is not a count but a sequence number initialized at
            an arbitrary point by the sender.</p></dd>

        <dt>link-credit</dt>
        <dd><p>The <i>link-credit</i> variable defines the current maximum legal amount that the
            <i>delivery-count</i> can be increased by. This identifies a <i>delivery-limit</i> that
            can be computed by adding the <i>link-credit</i> to the <i>delivery-count</i>.</p>

            <p>Only the receiver can independently choose a value for this field. The sender's value
            MUST always be maintained in such a way as to match the <i>delivery-limit</i> identified
            by the receiver. This means that the sender's link-credit variable MUST be set according
            to this formula when flow information is given by the receiver:</p>

            <p>
              <i>link-credit</i><sub>snd</sub> := <i>delivery-count</i><sub>rcv</sub> +
              <i>link-credit</i><sub>rcv</sub> - <i>delivery-count</i><sub>snd</sub>.
            </p>

            <p>
              In the event that the receiver does not yet know the <i>delivery-count</i>, i.e.,
              <i>delivery-count</i><sub>rcv</sub> is unspecified, the sender MUST assume that
              the <i>delivery-count</i><sub>rcv</sub> is the first
              <i>delivery-count</i><sub>snd</sub> sent from sender to receiver, i.e., the
              <i>delivery-count</i><sub>snd</sub> specified in the flow state carried by the initial
              <a href="#type-attach">attach</a> frame from the sender to the receiver.
            </p>

            <p>
              Additionally, whenever the sender increases <i>delivery-count</i>, it MUST decrease
              <i>link-credit</i> by the same amount in order to maintain the <i>delivery-limit</i>
              identified by the receiver.
            </p>
        </dd>

        <dt>available</dt>
        <dd><p>The <i>available</i> variable is controlled by the sender, and indicates to the
            receiver, that the sender could make use of the indicated amount of <i>link-credit</i>.
            Only the sender can independently modify this field. The receiver's value is calculated
            based on the last known value from the sender and any subsequent incoming messages
            received. The sender MAY transfer messages even if the available variable is zero.
            If this happens, the receiver MUST maintain a floor of zero in its calculation of
            the value of available.</p></dd>

        <dt>drain</dt>
        <dd><p>The drain flag indicates how the sender SHOULD behave when insufficient messages are
            available to consume the current link-credit. If set, the sender will (after sending all
            available messages) advance the delivery-count as much as possible, consuming all
            link-credit, and send the flow state to the receiver. Only the receiver can
            independently modify this field. The sender's value is always the last known value
            indicated by the receiver.</p></dd>
      </dl><p>
        If the link-credit is less than or equal to zero, i.e., the delivery-count is the same as or
        greater than the delivery-limit, a sender MUST NOT send more messages. If the link-credit is
        reduced by the receiver when transfers are in-flight, the receiver MAY either handle the
        excess messages normally or detach the link with a transfer-limit-exceeded error code.
      </p><table class="pre" summary="Flow Control"><caption style="caption-side:bottom">Figure 2.40: Flow Control</caption><tr><td>
     +----------+                                    +----------+
     |  Sender  |---------------transfer------------&gt;| Receiver |
     +----------+                                    +----------+
      \        / &lt;----------------flow--------------- \        /
       +------+                                        +------+
          |
          |
          |
 if link-credit &lt;= 0 then pause 
      </td></tr></table><p>
        If the sender's drain flag is set and there are no available messages, the sender MUST
        advance its delivery-count until link-credit is zero, and send its updated
        <a href="#type-flow">flow</a> state to the receiver.
      </p><p>
        The delivery-count is an absolute value. While the value itself is conceptually unbounded,
        it is encoded as a 32-bit integer that wraps around and compares according to RFC-1982
        [<a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-overview-v1.0-os.html#anchor-RFC1982">RFC1982</a>] serial number arithmetic.
      </p><p>
        The initial flow state of a link endpoint is determined as follows. The <i>link-credit</i>
        and <i>available</i> variables are initialized to zero. The <i>drain</i> flag is initialized
        to false. The sender MAY choose an arbitrary point to initialize the <i>delivery-count</i>.
        This value is communicated in the initial <a href="#type-attach">attach</a> frame. The receiver
        initializes its <i>delivery-count</i> upon receiving the sender's <a href="#type-attach">attach</a>.
      </p><table class="pre" summary="Flow State &amp; related Frames"><caption style="caption-side:bottom">Figure 2.41: Flow State &amp; related Frames</caption><tr><td>
                                flow state
                                    |
                                    | modifies
+------------------+                |               +------------------+
|      Sender      |    .----------------------.    |     Receiver     |
+------------------+     attach, transfer, flow     +------------------+
| delivery-count   |-------------------------------&gt;| delivery-count   |
| link-credit      |                                | link-credit      |
| available        |&lt;-------------------------------| available        |
| drain            |              flow              | drain            |
+------------------+             '-----'            +------------------+
                                    |
                                    | modifies
                                    |
                                flow state 
      </td></tr></table><p>
        The flow control semantics defined in this section provide the primitives necessary to
        implement a wide variety of flow control strategies. Additionally, by manipulating the
        link-credit and drain flag, a receiver can provide a variety of different higher level
        behaviors often useful to applications, including synchronous blocking fetch, synchronous
        fetch with a timeout, asynchronous notifications, and stopping/pausing.
      </p><table class="pre" summary="Flow Control Usage Patterns"><caption style="caption-side:bottom">Figure 2.42: Flow Control Usage Patterns</caption><tr><td>
            +----------+                                    +----------+
            | Receiver |&lt;--------------transfer-------------|  Sender  |
            +----------+                                    +----------+
             \        / -----------------flow--------------&gt; \        /
              +------+                                        +------+
                  |
                  |
                  |
    sync-get: flow(link-credit=1, ...)      ----&gt;
   timed-get: flow(link-credit=1, ...),
              *wait*,
              flow(drain=True, ...)         ----&gt;
async-notify: flow(link-credit=delta, ...)  ----&gt;
        stop: flow(link-credit=0, ...)      ----&gt; 
      </td></tr></table></div><h3><a class="toc" href="#toc">←</a>2.6.8 <a name="doc-idp416352">Synchronous Get</a></h3><div class="doc"><p>
        A synchronous get of a message from a link is accomplished by incrementing the link-credit,
        sending the updated <a href="#type-flow">flow</a> state, and waiting indefinitely for a
        <a href="#type-transfer">transfer</a> to arrive.
      </p><table class="pre" summary="Synchronous Get"><caption style="caption-side:bottom">Figure 2.43: Synchronous Get</caption><tr><td>
Receiver                                      Sender
=================================================================
                                      ...
flow(link-credit=1)               ----------&gt;
                                        +---- transfer(...)
*block until transfer arrives*         /
                                  &lt;---+
                                      ...
----------------------------------------------------------------- 
      </td></tr></table><p>
        Synchronous get with a timeout is accomplished by incrementing the link-credit, sending the
        updated <a href="#type-flow">flow</a> state and waiting for the link-credit to be consumed. When the
        desired time has elapsed the receiver then sets the drain flag and sends the newly updated
        <a href="#type-flow">flow</a> state again, while continuing to wait for the link-credit to be
        consumed. Even if no messages are available, this condition will be met promptly because of
        the drain flag. Once the link-credit is consumed, the receiver can unambiguously determine
        whether a message has arrived or whether the operation has timed out.
      </p><table class="pre" summary="Synchronous Get w/ Timeout"><caption style="caption-side:bottom">Figure 2.44: Synchronous Get w/ Timeout</caption><tr><td>
    Receiver                                      Sender
    =================================================================
                                          ...
    flow(link-credit=1)               ----------&gt;
  *wait for link-credit &lt;= 0*
    flow(drain=True)                  ---+   +--- transfer(...)
                                          \ /
                                           x
                                          / \
(1)                                   &lt;--+   +--&gt;
(2)                                   &lt;---------- flow(...)
                                          ...
    -----------------------------------------------------------------
      (1) If a message is available within the timeout, it will
          arrive at this point.
      (2) If a message is not available within the timeout, the
          drain flag will ensure that the sender promptly advances the
          delivery-count until link-credit is consumed.  
      </td></tr></table></div><h3><a class="toc" href="#toc">←</a>2.6.9 <a name="doc-idp424576">Asynchronous Notification</a></h3><div class="doc"><p>
        Asynchronous notification can be accomplished as follows. The receiver maintains a target
        amount of link-credit for that link. As <a href="#type-transfer" title="transfer">transfers</a> arrive on the
        link, the sender's link-credit decreases as the delivery-count increases. When the sender's
        link-credit falls below a threshold, the <a href="#type-flow">flow</a> state MAY be sent to increase
        the sender's link-credit back to the desired target amount.
      </p><table class="pre" summary="Asynchrnous Notification"><caption style="caption-side:bottom">Figure 2.45: Asynchrnous Notification</caption><tr><td>
Receiver                                          Sender
=====================================================================
                                      ...
                                  &lt;----------     transfer(...)
                                  &lt;----------     transfer(...)
flow(link-credit=delta)           ---+   +---     transfer(...)
                                      \ /
                                       x
                                      / \
                                  &lt;--+   +--&gt;
                                  &lt;----------     transfer(...)
                                  &lt;----------     transfer(...)
flow(link-credit=delta)           ---+   +---     transfer(...)
                                      \ /
                                       x
                                      / \
                                  &lt;--+   +--&gt;
                                      ...
---------------------------------------------------------------------
  The incoming message rate for the link is limited by the
  rate at which the receiver updates the delivery-limit by
  issuing link-credit.  
      </td></tr></table></div><h3><a class="toc" href="#toc">←</a>2.6.10 <a name="doc-idp429232">Stopping A Link</a></h3><div class="doc"><p>
        Stopping the transfers on a given link is accomplished by updating the link-credit to be
        zero and sending the updated <a href="#type-flow">flow</a> state. It is possible that some transfers
        could be in flight at the time the <a href="#type-flow">flow</a> state is sent, so incoming transfers
        could still arrive on the link. The echo field of the <a href="#type-flow">flow</a> frame MAY be used
        to request the sender's <a href="#type-flow">flow</a> state be echoed back. This MAY be used to
        determine when the link has finally quiesced.
      </p><table class="pre" summary="Stopping Incoming Messages"><caption style="caption-side:bottom">Figure 2.46: Stopping Incoming Messages</caption><tr><td>
    Receiver                                       Sender
    ================================================================
                                           ...
                                       &lt;---------- transfer(...)
    flow(...,                          ---+   +--- transfer(...)
         link-credit=0,                    \ /
         echo=True)                         x
                                           / \
(1)                                    &lt;--+   +--&gt;
(2)                                    &lt;---------- flow(...)
                                           ...
    ----------------------------------------------------------------
      (1) In-flight transfers can still arrive until the flow state
          is updated at the sender.
      (2) At this point no further transfers will arrive.  
      </td></tr></table></div><h3><a class="toc" href="#toc">←</a>2.6.11 <a name="doc-idp434960">Messages</a></h3><div class="doc"><p>
        The transport layer assumes as little as possible about messages and allows alternative
        message representations to be layered above. Message data is carried as the payload in
        frames containing the <a href="#type-transfer">transfer</a> performative. Messages can be fragmented
        across several <a href="#type-transfer">transfer</a> frames as indicated by the more flag of the <a href="#type-transfer">transfer</a> performative.
      </p></div><h3><a class="toc" href="#toc">←</a>2.6.12 <a name="doc-idp438000">Transferring A Message</a></h3><div class="doc"><p>
        When an application initiates a message transfer, it assigns a delivery-tag used to track
        the state of the delivery while the message is in transit. A delivery is considered
        <i>unsettled</i> at the sender/receiver from the point at which it was sent/received until
        it has been <i>settled</i> by the sending/receiving application. Each delivery MUST be
        identified by a delivery-tag chosen by the sending application. The delivery-tag MUST be
        unique amongst all deliveries that could be considered unsettled by either end of the link.
      </p><p>
        Upon initiating a transfer, the application will supply the sending link endpoint (Sender)
        with the message data and its associated delivery-tag. The sender will create an entry in
        its unsettled map, and send a transfer frame that includes the delivery-tag, the delivery's
        initial state, and its associated message data. For brevity on the wire, the delivery-tag is
        also associated with a delivery-id assigned by the session. The delivery-id is then used to
        refer to the delivery-tag in all subsequent interactions on that session.
      </p><p>
        The following diagrams illustrate the fundamentals involved in transferring a message. For
        normative semantics please refer to the definitions of the <a href="#type-transfer">transfer</a> and <a href="#type-disposition">disposition</a> performatives. For simplicity the delivery-id is omitted in the
        following diagrams and the delivery-tag is itself used directly. These diagrams also assume
        that this interaction takes place in the context of a single established link, and as such
        omit other details that would be present on the wire in practice such as the channel number,
        link handle, fragmentation flags, etc., focusing only on the essential aspects of message
        transfer.
      </p><table class="pre" summary="Initial Transfer"><caption style="caption-side:bottom">Figure 2.47: Initial Transfer</caption><tr><td>
  +------------------+
 /       Sender       \
+----------------------+
| unsettled:           |    transfer(delivery-tag=DT, settled=False,
|   ...                |             state=S_0, ...)
|   DT -&gt; (local: S_0, |-----------------------------------------------&gt;
|          remote: ?)  |
|   ...                |
+----------------------+ 
      </td></tr></table><p>
        Upon receiving the transfer, the receiving link endpoint (receiver) will create an entry in
        its own unsettled map and make the transferred message data available to the application to
        process.
      </p><table class="pre" summary="Initial Receipt"><caption style="caption-side:bottom">Figure 2.48: Initial Receipt</caption><tr><td>
                                                  +------------------+
                                                 /      Receiver      \
                                                +----------------------+
    transfer(delivery-tag=DT, settled=False,    | unsettled:           |
             state=S_0, ...)                    |   ...                |
-----------------------------------------------&gt;|   DT -&gt; (local: S_1, |
                                                |          remote: S_0)|
                                                |   ...                |
                                                +----------------------+
      </td></tr></table><p>
        Once notified of the received message data, the application processes the message,
        indicating the updated delivery state to the link endpoint as desired. Applications MAY wish
        to classify delivery states as <i>terminal</i> or <i>non-terminal</i> depending
        on whether an endpoint will ever update the state further once it has been reached. In some
        cases (e.g., large messages or transactions), the receiving application MAY wish to indicate
        non-terminal delivery states to the sender. This is done via the <a href="#type-disposition">disposition</a>
        frame.
      </p><table class="pre" summary="Indication of Non-Terminal State"><caption style="caption-side:bottom">Figure 2.49: Indication of Non-Terminal State</caption><tr><td>
                                                  +------------------+
                                                 /      Receiver      \
                                                +----------------------+
                                                | unsettled:           |
                                                |   ...                |
&lt;-----------------------------------------------|   DT -&gt; (local: S_2, |
    disp(role=receiver, ..., delivery-tag=DT,   |          remote: S_0)|
         settled=False, state=S_2, ...)         |   ...                |
                                                +----------------------+
      </td></tr></table><p>
        Once the receiving application has finished processing the message, it indicates to the link
        endpoint a <i>terminal</i> delivery state that reflects the outcome of the application
        processing (successful or otherwise) and thus the outcome which the receiver wishes to occur
        at the sender. This state is communicated back to the sender via the <a href="#type-disposition">disposition</a> frame.
      </p><table class="pre" summary="Indication of Presumptive Terminal State"><caption style="caption-side:bottom">Figure 2.50: Indication of Presumptive Terminal State</caption><tr><td>
                                                  +------------------+
                                                 /      Receiver      \
                                                +----------------------+
                                                | unsettled:           |
                                                |   ...                |
&lt;-----------------------------------------------|   DT -&gt; (local: T_0, |
    disp(role=receiver, ..., delivery-tag=DT,   |          remote: S_0)|
         settled=False, state=T_0, ...)         |   ...                |
                                                +----------------------+
      </td></tr></table><p>
        Upon receiving the updated delivery state from the receiver, the sender will, if it has not
        already spontaneously attained a terminal state (e.g., through the expiry of the TTL at the
        sender), update its view of the state and communicate this back to the sending application.
      </p><table class="pre" summary="Receipt of Terminal State"><caption style="caption-side:bottom">Figure 2.51: Receipt of Terminal State</caption><tr><td>
  +------------------+
 /       Sender       \
+----------------------+
| unsettled:           |
|   ...                |
|   DT -&gt; (local: S_0, |&lt;-----------------------------------------------
|          remote: T_0)|    disp(role=receiver, ..., delivery-tag=DT,
|   ...                |         settled=False, state=T_0, ...)
+----------------------+
      </td></tr></table><p>
        The sending application will then typically perform some action based on this terminal state
        and then settle the delivery, causing the sender to remove the delivery-tag from its
        unsettled map. The sender will then send its final delivery state along with an indication
        that the delivery is settled at the sender. Note that this amounts to the sender announcing
        that it is forever forgetting everything about the delivery-tag in question, and as such it
        is only possible to make such an announcement once, since after the sender forgets, it has
        no way of remembering to make the announcement again. If this frame gets lost due to an
        interruption in communication, the receiver will find out that the sender has settled the
        delivery upon link recovery. When the sender re-attaches the receiver will examine the
        unsettled state of the sender (i.e., what has <b>not</b> been forgotten) and from this can
        derive that the delivery in question has been settled (since its tag will not be in the
        unsettled state).
      </p><table class="pre" summary="Indication of Settlement"><caption style="caption-side:bottom">Figure 2.52: Indication of Settlement</caption><tr><td>
  +------------------+
 /       Sender       \
+----------------------+
| unsettled:           |    disp(role=sender, ..., delivery-tag=DT,
|   ...                |         settled=True, state=T_1, ...)
|   - -&gt; -             |-----------------------------------------------&gt;
|   ...                |
+----------------------+
      </td></tr></table><p>
        When the receiver finds out that the sender has settled the delivery, the receiver will
        update its view of the remote state to indicate this, and then notify the receiving
        application.
      </p><table class="pre" summary="Receipt of Settlement"><caption style="caption-side:bottom">Figure 2.53: Receipt of Settlement</caption><tr><td>
                                                  +------------------+
                                                 /      Receiver      \
                                                +----------------------+
     disp(role=sender, ..., delivery-tag=DT,    | unsettled:           |
          settled=True, state=T_1, ...)         |   ...                |
-----------------------------------------------&gt;|   DT -&gt; (local: S_2, |
                                                |          remote: - ) |
                                                |   ...                |
                                                +----------------------+
      </td></tr></table><p>
        The application can then perform some final action, e.g., remove the delivery-tag from a set
        kept for de-duplication, and then notify the receiver that the delivery is settled. The
        receiver will then remove the delivery-tag from its unsettled map. Note that because the
        receiver knows that the delivery is already settled at the sender, it makes no effort to
        notify the other endpoint that it is settling the delivery.
      </p><table class="pre" summary="Final Settlement"><caption style="caption-side:bottom">Figure 2.54: Final Settlement</caption><tr><td>
                                                  +------------------+
                                                 /      Receiver      \
                                                +----------------------+
                                                | unsettled:           |
                                                |   ...                |
&lt;-----------------------------------------------|   - -&gt; -             |
                                                |   ...                |
                                                +----------------------+
      </td></tr></table><p>
        As alluded to above, it is possible for the sending application to transition a delivery to
        a terminal state at the sender spontaneously (i.e., not as a consequence of a disposition
        that has been received from the receiver). In this case the sender SHOULD send a disposition
        to the receiver, but not settle until the receiver confirms, via a disposition in the
        opposite direction, that it has updated the state at its endpoint.
      </p><p>
        This set of exchanges illustrates the basic principals of message transfer. While a delivery
        is unsettled the endpoints exchange the current state of the delivery. Eventually both
        endpoints reach a terminal state as indicated by the application. This triggers the other
        application to take some final action and settle the delivery, and once one endpoint
        settles, this usually triggers the application at the other endpoint to settle.
      </p><p>
        This basic pattern can be modified in a variety of ways to achieve different guarantees. For
        example if the sending application settles the delivery <i>before</i> sending it, this
        results in an <i>at-most-once</i> guarantee. The sender has indicated up front with his
        initial transmission that he has forgotten everything about this delivery and will therefore
        make no further attempts to send it. If this delivery makes it to the receiver, the
        receiver clearly has no obligation to respond with updates of the receiver's delivery state,
        as they would be meaningless and ignored by the sender.
      </p><table class="pre" summary="At-Most-Once"><caption style="caption-side:bottom">Figure 2.55: At-Most-Once</caption><tr><td>
  +------------------+
 /       Sender       \
+----------------------+
| unsettled:           |    transfer(delivery-tag=DT, settled=True,
|   ...                |             state=T_0, ...)
|   - -&gt; -             |-----------------------------------------------&gt;
|   ...                |
+----------------------+
      </td></tr></table><p>
        Similarly, if the basic scenario is modified such that the receiving application chooses to
        settle immediately upon processing the message rather than waiting for the sender to settle
        first, that yields an <i>at-least-once</i> guarantee. If the disposition frame indicated
        below is lost, then upon link recovery the sender will not see the delivery-tag in the
        receiver's unsettled map and will therefore assume the delivery was lost and resend it,
        resulting in duplicate processing of the message at the receiver.
      </p><table class="pre" summary="At-Least-Once"><caption style="caption-side:bottom">Figure 2.56: At-Least-Once</caption><tr><td>
                                                  +------------------+
                                                 /      Receiver      \
                                                +----------------------+
                                                | unsettled:           |
                                                |   ...                |
&lt;-----------------------------------------------|   - -&gt; -             |
    disp(role=receiver, ..., delivery-tag=DT,   |   ...                |
         settled=True, state=T_0, ...)          |                      |
                                                +----------------------+
      </td></tr></table><p>
        As one might guess, the scenario presented initially where the sending application settles
        when the receiver reaches a terminal state, and the receiving application settles when the
        sender settles, results in an <i>exactly-once</i> guarantee. More generally if the receiver
        settles prior to the sender, it is possible for duplicate messages to occur, except in the
        case where the sender settles before the initial transmission. Similarly, if the sender
        settles before the receiver reaches a terminal state, it is possible for messages to be
        lost.
      </p><p>
        The sender and receiver policy regarding settling can either be preconfigured for the
        entire link, thereby allowing for optimized endpoint choices, or can be determined on an
        ad-hoc basis for each delivery. An application MAY also choose to settle at an endpoint
        independently of its delivery state, for example the sending application MAY choose to
        settle a delivery due to the message ttl expiring regardless of whether the receiver has
        reached a terminal state.
      </p></div><h3><a class="toc" href="#toc">←</a>2.6.13 <a name="doc-resuming-deliveries">Resuming Deliveries</a></h3><div class="doc"><p>
        When a suspended link having unsettled deliveries is resumed, the <i>unsettled</i> field
        from the <a href="#type-attach">attach</a> frame will carry the delivery-tags and delivery state of all
        deliveries considered unsettled by the issuing link endpoint. The set of delivery tags and
        delivery states contained in the unsettled maps from both endpoints can be divided into
        three categories:
      </p><dl>
        <dt>Deliveries that only the source considers unsettled</dt>
        <dd><p>Deliveries in this category MAY be resumed at the discretion of the sending
            application. If the sending application marks the resend attempt as a resumed delivery
            then it MUST be ignored by the receiver. (This allows the sender to pipeline resumes
            without risk of duplication at the sender).</p></dd>

        <dt>Deliveries that only the target considers unsettled</dt>
        <dd><p>Deliveries in this category MUST be ignored by the sender, and MUST be considered
            settled by the receiver.</p></dd>

        <dt>Deliveries that both the source and target consider unsettled</dt>
        <dd><p>Deliveries in this category MUST be resumed by the sender.</p></dd>
      </dl><p>
        Note that in the case where an endpoint indicates that the unsettled map is incomplete, the
        absence of an entry in the unsettled map is not an indication of settlement. In this case
        the two endpoints MUST reduce the levels of unsettled state as much as they can by the
        sender resuming and/or settling transfers that it observes that the receiver considers
        unsettled. Upon completion of this reduction of state, the two parties MUST suspend and
        re-attempt to resume the link. Only when both sides have complete unsettled maps can new
        unsettled state be created by the sending of non-resuming transfers.
      </p><p>
        A delivery is resumed much the same way it is initially transferred with the following
        exceptions:
      </p><ul>
        <li><p>The resume flag of the <a href="#type-transfer">transfer</a> frame MUST be set to true when
            resuming a delivery.</p></li>
        <li><p>The sender MAY omit message data when the delivery state of the receiver indicates
            retransmission is unnecessary.</p></li>
      </ul><p>
        Note that unsettled delivery-tags do NOT have any valid delivery-ids associated until they
        are resumed, as the delivery-ids from their original link endpoints are meaningless to the
        new link endpoints.
      </p></div><h3><a class="toc" href="#toc">←</a>2.6.14 <a name="doc-idp484080">Transferring Large Messages</a></h3><div class="doc"><p>
        Each <a href="#type-transfer">transfer</a> frame can carry an arbitrary amount of message data up to the
        limit imposed by the maximum frame size. For messages that are too large to fit within the
        maximum frame size, additional data MAY be transferred in additional <a href="#type-transfer">transfer</a>
        frames by setting the more flag on all but the last <a href="#type-transfer">transfer</a> frame. When a
        message is split up into multiple <a href="#type-transfer">transfer</a> frames in this manner, messages
        being transferred along different links MAY be interleaved. However, messages transferred
        along a single link MUST NOT be interleaved.
      </p><p>
        The sender MAY indicate an aborted attempt to deliver a message by setting the abort flag on
        the last <a href="#type-transfer">transfer</a>. In this case the receiver MUST discard the
        message data that was transferred prior to the abort.
      </p><table class="pre" summary="Outgoing Fragmentation State Diagram"><caption style="caption-side:bottom">Figure 2.57: Outgoing Fragmentation State Diagram</caption><tr><td>
              +------------+  S:XFR(M=1,A=0)
       +------|  NOT_SENT  |------+
       |      +------------+      |
       |                          |
       | S:XFR(M=0,A=0)           |
       |                          |     S:XFR(M=1,A=0)
       |                          |      +----------+
       |                          |      |          |
       |                         \|/    \|/         |
       |                       +------------+       |
       |      +----------------|  SENDING   |-------+
       |      | S:XFR(M=0,A=0) +------------+
       |      |                      |
       |      |                      |
       |      |                      | S:XFR(M=0,A=1)
       |      |                      |
      \|/    \|/                    \|/
    +------------+             +------------+
    |    SENT    |             |  ABORTED   |
    +------------+             +------------+

Key: S:XFR(M=?,A=?) --&gt; Sent TRANSFER(more=?, aborted=?) 
      </td></tr></table><table class="pre" summary="Incoming Fragmentation State Diagram"><caption style="caption-side:bottom">Figure 2.58: Incoming Fragmentation State Diagram</caption><tr><td>
              +------------+  R:XFR(M=1,A=0)
       +------|  NOT_RCVD  |------+
       |      +------------+      |
       |                          |
       | R:XFR(M=0,A=0)           |
       |                          |     R:XFR(M=1,A=0)
       |                          |      +----------+
       |                          |      |          |
       |                         \|/    \|/         |
       |                       +------------+       |
       |      +----------------| RECEIVING  |-------+
       |      | R:XFR(M=0,A=0) +------------+
       |      |                      |
       |      |                      |
       |      |                      | R:XFR(M=0,A=1)
       |      |                      |
      \|/    \|/                    \|/
    +------------+             +------------+
    |  RECEIVED  |             |  ABORTED   |
    +------------+             +------------+

Key: R:XFR(M=?,A=?) --&gt; Received TRANSFER(more=?, aborted=?)
      </td></tr></table></div></div>

  <h2><a class="toc" href="#toc">←</a>2.7 <a name="section-performatives">Performatives</a></h2><div class="section"><h3><a class="toc" href="#toc">←</a>2.7.1 <a name="type-open">Open</a></h3><p>Negotiate connection parameters.</p><table class="signature" summary="@(label)"><tr><td>&lt;type name="open" class="composite" source="list" provides="frame"&gt;
    &lt;descriptor name="amqp:open:list" code="0x00000000:0x00000010"/&gt;
    &lt;field name="container-id" type="string" mandatory="true"/&gt;
    &lt;field name="hostname" type="string"/&gt;
    &lt;field name="max-frame-size" type="uint" default="4294967295"/&gt;
    &lt;field name="channel-max" type="ushort" default="65535"/&gt;
    &lt;field name="idle-time-out" type="milliseconds"/&gt;
    &lt;field name="outgoing-locales" type="ietf-language-tag" multiple="true"/&gt;
    &lt;field name="incoming-locales" type="ietf-language-tag" multiple="true"/&gt;
    &lt;field name="offered-capabilities" type="symbol" multiple="true"/&gt;
    &lt;field name="desired-capabilities" type="symbol" multiple="true"/&gt;
    &lt;field name="properties" type="fields"/&gt;
&lt;/type&gt;</td></tr></table><div class="doc"><p>
          The first frame sent on a connection in either direction MUST contain an open
          performative. Note that the connection header which is sent first on the connection is
          <b>not</b> a frame.
        </p><p>
          The fields indicate the capabilities and limitations of the sending peer.
        </p></div><table class="composite" summary="open fields"><tr><td><b>container-id</b></td><td><i>the id of the source container</i></td><td>mandatory <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#type-string">string</a></td></tr><tr><td class="field" colspan="2"></td></tr><tr><td><b>hostname</b></td><td><i>the name of the target host</i></td><td>optional <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#type-string">string</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            The name of the host (either fully qualified or relative) to which the sending peer
            is connecting. It is not mandatory to provide the hostname. If no hostname is provided
            the receiving peer SHOULD select a default based on its own configuration. This field
            can be used by AMQP proxies to determine the correct back-end service to connect
            the client to.
          </p><p>
            This field MAY already have been specified by the <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-security-v1.0-os.html#type-sasl-init">sasl-init</a> frame, if a
            SASL layer is used, or, the server name indication extension as described in
            RFC-4366, if a TLS layer is used, in which case this field SHOULD be null or contain
            the same value. It is undefined what a different value to that already specified
            means.
          </p></div></td></tr><tr><td><b>max-frame-size</b></td><td><i>proposed maximum frame size</i></td><td>optional <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#type-uint">uint</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            The largest frame size that the sending peer is able to accept on this connection. If
            this field is not set it means that the peer does not impose any specific limit. A peer
            MUST NOT send frames larger than its partner can handle. A peer that receives an
            oversized frame MUST close the connection with the framing-error error-code.
          </p><p>
            Both peers MUST accept frames of up to <a href="#definition-MIN-MAX-FRAME-SIZE">512 (MIN-MAX-FRAME-SIZE)</a> octets.
          </p></div></td></tr><tr><td><b>channel-max</b></td><td><i>the maximum channel number that can be used on the connection</i></td><td>optional <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#type-ushort">ushort</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            The channel-max value is the highest channel number that can be used on the connection.
            This value plus one is the maximum number of sessions that can be simultaneously active
            on the connection. A peer MUST not use channel numbers outside the range that its
            partner can handle. A peer that receives a channel number outside the supported range
            MUST close the connection with the framing-error error-code.
          </p></div></td></tr><tr><td><b>idle-time-out</b></td><td><i>idle time-out</i></td><td>optional <a href="#type-milliseconds">milliseconds</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            The idle timeout  REQUIRED by the sender (see <a href="#doc-doc-idle-time-out" title="doc-idle-time-out">subsection 2.4.5</a>). A value
            of zero is the same as if it was not set (null). If the receiver is unable or unwilling
            to support the idle time-out then it SHOULD close the connection with an error
            explaining why (e.g., because it is too small).
          </p><p>
            If the value is not set, then the sender does not have an idle time-out. However,
            senders doing this SHOULD be aware that implementations MAY choose to use an
            internal default to efficiently manage a peer's resources.
          </p></div></td></tr><tr><td><b>outgoing-locales</b></td><td><i>locales available for outgoing text</i></td><td>optional <a href="#type-ietf-language-tag">ietf-language-tag</a>[]</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            A list of the locales that the peer supports for sending informational text. This
            includes connection, session and link error descriptions. A peer MUST support at least
            the <i>en-US</i> locale (see <a href="#type-ietf-language-tag" title="ietf-language-tag">subsection 2.8.12</a>). Since this value is
            always supported, it need not be supplied in the outgoing-locales. A null value or an
            empty list implies that only <i>en-US</i> is supported.
          </p></div></td></tr><tr><td><b>incoming-locales</b></td><td><i>desired locales for incoming text in decreasing level of preference</i></td><td>optional <a href="#type-ietf-language-tag">ietf-language-tag</a>[]</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            A list of locales that the sending peer permits for incoming informational text. This
            list is ordered in decreasing level of preference. The receiving partner will choose the
            first (most preferred) incoming locale from those which it supports. If none of the
            requested locales are supported, <i>en-US</i> will be chosen. Note that <i>en-US</i>
            need not be supplied in this list as it is always the fallback. A peer MAY determine
            which of the permitted incoming locales is chosen by examining the partner's supported
            locales as specified in the outgoing-locales field. A null value or an empty list
            implies that only <i>en-US</i> is supported.
          </p></div></td></tr><tr><td><b>offered-capabilities</b></td><td><i>extension capabilities the sender supports</i></td><td>optional <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#type-symbol">symbol</a>[]</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            If the receiver of the offered-capabilities requires an extension capability which is
            not present in the offered-capability list then it MUST close the connection.
          </p><p>
            A registry of commonly defined connection capabilities and their meanings is maintained
            [<a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-overview-v1.0-os.html#anchor-AMQPCONNCAP">AMQPCONNCAP</a>].
          </p></div></td></tr><tr><td><b>desired-capabilities</b></td><td><i>extension capabilities the sender can use if the receiver supports them</i></td><td>optional <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#type-symbol">symbol</a>[]</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            The desired-capability list defines which extension capabilities the sender MAY use if
            the receiver offers them (i.e., they are in the offered-capabilities list received by
            the sender of the desired-capabilities). The sender MUST NOT attempt to use any
            capabilities it did not declare in the desired-capabilities field. If the receiver of
            the desired-capabilities offers extension capabilities which are not present in the
            desired-capabilities list it received, then it can be sure those (undesired)
            capabilities will not be used on the connection.
          </p></div></td></tr><tr><td><b>properties</b></td><td><i>connection properties</i></td><td>optional <a href="#type-fields">fields</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            The properties map contains a set of fields intended to indicate information about the
            connection and its container.
          </p><p>
            A registry of commonly defined connection properties and their meanings is maintained
            [<a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-overview-v1.0-os.html#anchor-AMQPCONNPROP">AMQPCONNPROP</a>].
          </p></div></td></tr></table><h3><a class="toc" href="#toc">←</a>2.7.2 <a name="type-begin">Begin</a></h3><p>Begin a session on a channel.</p><table class="signature" summary="@(label)"><tr><td>&lt;type name="begin" class="composite" source="list" provides="frame"&gt;
    &lt;descriptor name="amqp:begin:list" code="0x00000000:0x00000011"/&gt;
    &lt;field name="remote-channel" type="ushort"/&gt;
    &lt;field name="next-outgoing-id" type="transfer-number" mandatory="true"/&gt;
    &lt;field name="incoming-window" type="uint" mandatory="true"/&gt;
    &lt;field name="outgoing-window" type="uint" mandatory="true"/&gt;
    &lt;field name="handle-max" type="handle" default="4294967295"/&gt;
    &lt;field name="offered-capabilities" type="symbol" multiple="true"/&gt;
    &lt;field name="desired-capabilities" type="symbol" multiple="true"/&gt;
    &lt;field name="properties" type="fields"/&gt;
&lt;/type&gt;</td></tr></table><div class="doc"><p>
          Indicate that a session has begun on the channel.
        </p></div><table class="composite" summary="begin fields"><tr><td><b>remote-channel</b></td><td><i>the remote channel for this session</i></td><td>optional <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#type-ushort">ushort</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            If a session is locally initiated, the remote-channel MUST NOT be set. When an endpoint
            responds to a remotely initiated session, the remote-channel MUST be set to the channel
            on which the remote session sent the begin.
          </p></div></td></tr><tr><td><b>next-outgoing-id</b></td><td><i>the transfer-id of the first transfer id the sender will send</i></td><td>mandatory <a href="#type-transfer-number">transfer-number</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>See <a href="#doc-session-flow-control" title="session-flow-control">subsection 2.5.6</a>.</p></div></td></tr><tr><td><b>incoming-window</b></td><td><i>the initial incoming-window of the sender</i></td><td>mandatory <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#type-uint">uint</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>See <a href="#doc-session-flow-control" title="session-flow-control">subsection 2.5.6</a>.</p></div></td></tr><tr><td><b>outgoing-window</b></td><td><i>the initial outgoing-window of the sender</i></td><td>mandatory <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#type-uint">uint</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>See <a href="#doc-session-flow-control" title="session-flow-control">subsection 2.5.6</a>.</p></div></td></tr><tr><td><b>handle-max</b></td><td><i>the maximum handle value that can be used on the session</i></td><td>optional <a href="#type-handle">handle</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            The handle-max value is the highest handle value that can be used on the session.
            A peer MUST NOT attempt to attach a link using a handle value outside the range that its
            partner can handle. A peer that receives a handle outside the supported range MUST close
            the connection with the framing-error error-code.
          </p></div></td></tr><tr><td><b>offered-capabilities</b></td><td><i>the extension capabilities the sender supports</i></td><td>optional <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#type-symbol">symbol</a>[]</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            A registry of commonly defined session capabilities and their meanings is maintained
            [<a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-overview-v1.0-os.html#anchor-AMQPSESSCAP">AMQPSESSCAP</a>].
          </p></div></td></tr><tr><td><b>desired-capabilities</b></td><td><i>the extension capabilities the sender can use if the receiver supports them</i></td><td>optional <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#type-symbol">symbol</a>[]</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            The sender MUST NOT attempt to use any capability other than those it has declared in
            desired-capabilities field.
          </p></div></td></tr><tr><td><b>properties</b></td><td><i>session properties</i></td><td>optional <a href="#type-fields">fields</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            The properties map contains a set of fields intended to indicate information about the
            session and its container.
          </p><p>
            A registry of commonly defined session properties and their meanings is maintained
            [<a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-overview-v1.0-os.html#anchor-AMQPSESSPROP">AMQPSESSPROP</a>].
          </p></div></td></tr></table><h3><a class="toc" href="#toc">←</a>2.7.3 <a name="type-attach">Attach</a></h3><p>Attach a link to a session.</p><table class="signature" summary="@(label)"><tr><td>&lt;type name="attach" class="composite" source="list" provides="frame"&gt;
    &lt;descriptor name="amqp:attach:list" code="0x00000000:0x00000012"/&gt;
    &lt;field name="name" type="string" mandatory="true"/&gt;
    &lt;field name="handle" type="handle" mandatory="true"/&gt;
    &lt;field name="role" type="role" mandatory="true"/&gt;
    &lt;field name="snd-settle-mode" type="sender-settle-mode" default="mixed"/&gt;
    &lt;field name="rcv-settle-mode" type="receiver-settle-mode" default="first"/&gt;
    &lt;field name="source" type="*" requires="source"/&gt;
    &lt;field name="target" type="*" requires="target"/&gt;
    &lt;field name="unsettled" type="map"/&gt;
    &lt;field name="incomplete-unsettled" type="boolean" default="false"/&gt;
    &lt;field name="initial-delivery-count" type="sequence-no"/&gt;
    &lt;field name="max-message-size" type="ulong"/&gt;
    &lt;field name="offered-capabilities" type="symbol" multiple="true"/&gt;
    &lt;field name="desired-capabilities" type="symbol" multiple="true"/&gt;
    &lt;field name="properties" type="fields"/&gt;
&lt;/type&gt;</td></tr></table><div class="doc"><p>
          The <a href="#type-attach">attach</a> frame indicates that a link endpoint has been
          attached to the session.
        </p></div><table class="composite" summary="attach fields"><tr><td><b>name</b></td><td><i>the name of the link</i></td><td>mandatory <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#type-string">string</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            This name uniquely identifies the link from the container of the source to the container
            of the target node, e.g., if the container of the source node is A, and the container of
            the target node is B, the link MAY be globally identified by the (ordered) tuple
            <i>(A,B,&lt;name&gt;)</i>.
          </p></div></td></tr><tr><td><b>handle</b></td><td><i>the handle for the link while attached</i></td><td>mandatory <a href="#type-handle">handle</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            The numeric handle assigned by the the peer as a shorthand to refer to the link in all
            performatives that reference the link until the it is detached. See <a href="#doc-link-handles" title="link-handles">subsection 2.6.2</a>.
          </p><p>
            The handle MUST NOT be used for other open links. An attempt to attach using a handle
            which is already associated with a link MUST be responded to with an immediate
            <a href="#type-close">close</a> carrying a handle-in-use <a href="#type-session-error">session-error</a>.
           </p><p>
             To make it easier to monitor AMQP link attach frames, it is RECOMMENDED that
             implementations always assign the lowest available handle to this field.
           </p></div></td></tr><tr><td><b>role</b></td><td><i>role of the link endpoint</i></td><td>mandatory <a href="#type-role">role</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            The role being played by the peer, i.e., whether the peer is the sender or the receiver
            of messages on the link.
          </p></div></td></tr><tr><td><b>snd-settle-mode</b></td><td><i>settlement policy for the sender</i></td><td>optional <a href="#type-sender-settle-mode">sender-settle-mode</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            The delivery settlement policy for the sender. When set at the receiver this indicates
            the desired value for the settlement mode at the sender. When set at the sender this
            indicates the actual settlement mode in use. The sender SHOULD respect the receiver's
            desired settlement mode if the receiver initiates the attach exchange and the sender
            supports the desired mode.
          </p></div></td></tr><tr><td><b>rcv-settle-mode</b></td><td><i>the settlement policy of the receiver</i></td><td>optional <a href="#type-receiver-settle-mode">receiver-settle-mode</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            The delivery settlement policy for the receiver. When set at the sender this indicates
            the desired value for the settlement mode at the receiver. When set at the receiver this
            indicates the actual settlement mode in use. The receiver SHOULD respect the sender's
            desired settlement mode if the sender initiates the attach exchange and the receiver
            supports the desired mode.
          </p></div></td></tr><tr><td><b>source</b></td><td><i>the source for messages</i></td><td>optional *</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            If no source is specified on an outgoing link, then there is no source currently
            attached to the link. A link with no source will never produce outgoing messages.
          </p></div></td></tr><tr><td><b>target</b></td><td><i>the target for messages</i></td><td>optional *</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            If no target is specified on an incoming link, then there is no target currently
            attached to the link. A link with no target will never permit incoming messages.
          </p></div></td></tr><tr><td><b>unsettled</b></td><td><i>unsettled delivery state</i></td><td>optional <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#type-map">map</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            This is used to indicate any unsettled delivery states when a suspended link is resumed.
            The map is keyed by delivery-tag with values indicating the delivery state. The local
            and remote delivery states for a given delivery-tag MUST be compared to resolve any
            in-doubt deliveries. If necessary, deliveries MAY be resent, or resumed based on the
            outcome of this comparison. See <a href="#doc-resuming-deliveries" title="resuming-deliveries">subsection 2.6.13</a>.
          </p><p>
            If the local unsettled map is too large to be encoded within a frame of the agreed
            maximum frame size then the session MAY be ended with the <a href="#choice-amqp-error-frame-size-too-small">frame-size-too-small</a> error. The endpoint SHOULD make use of
            the ability to send an incomplete unsettled map (see below) to avoid sending an error.
          </p><p>
            The unsettled map MUST NOT contain null valued keys.
          </p><p>
            When reattaching (as opposed to resuming), the unsettled map MUST be null.
          </p></div></td></tr><tr><td><b>incomplete-unsettled</b></td><td><i></i></td><td>optional <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#type-boolean">boolean</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            If set to true this field indicates that the unsettled map provided is not complete.
            When the map is incomplete the recipient of the map cannot take the absence of a
            delivery tag from the map as evidence of settlement. On receipt of an incomplete
            unsettled map a sending endpoint MUST NOT send any new deliveries (i.e. deliveries where
            resume is not set to true) to its partner (and a receiving endpoint which sent an
            incomplete unsettled map MUST detach with an error on receiving a transfer which does
            not have the resume flag set to true).
          </p><p>
            Note that if this flag is set to true then the endpoints MUST detach and reattach at
            least once in order to send new deliveries. This flag can be useful when there are too
            many entries in the unsettled map to fit within a single frame. An endpoint can attach,
            resume, settle, and detach until enough unsettled state has been cleared for an attach
            where this flag is set to false.
          </p></div></td></tr><tr><td><b>initial-delivery-count</b></td><td><i>the sender's initial value for delivery-count</i></td><td>optional <a href="#type-sequence-no">sequence-no</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            This MUST NOT be null if role is sender, and it is ignored if the role is receiver. See
            <a href="#doc-flow-control" title="flow-control">subsection 2.6.7</a>.
          </p></div></td></tr><tr><td><b>max-message-size</b></td><td><i>the maximum message size supported by the link endpoint</i></td><td>optional <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#type-ulong">ulong</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            This field indicates the maximum message size supported by the link endpoint. Any
            attempt to deliver a message larger than this results in a message-size-exceeded
            <a href="#type-link-error">link-error</a>. If this field is zero or unset, there is no maximum size
            imposed by the link endpoint.
          </p></div></td></tr><tr><td><b>offered-capabilities</b></td><td><i>the extension capabilities the sender supports</i></td><td>optional <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#type-symbol">symbol</a>[]</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            A registry of commonly defined link capabilities and their meanings is maintained
            [<a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-overview-v1.0-os.html#anchor-AMQPLINKCAP">AMQPLINKCAP</a>].
          </p></div></td></tr><tr><td><b>desired-capabilities</b></td><td><i>the extension capabilities the sender can use if the receiver supports them</i></td><td>optional <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#type-symbol">symbol</a>[]</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            The sender MUST NOT attempt to use any capability other than those it has declared in
            desired-capabilities field.
          </p></div></td></tr><tr><td><b>properties</b></td><td><i>link properties</i></td><td>optional <a href="#type-fields">fields</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            The properties map contains a set of fields intended to indicate information about the
            link and its container.
          </p><p>
            A registry of commonly defined link properties and their meanings is maintained
            [<a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-overview-v1.0-os.html#anchor-AMQPLINKPROP">AMQPLINKPROP</a>].
          </p></div></td></tr></table><h3><a class="toc" href="#toc">←</a>2.7.4 <a name="type-flow">Flow</a></h3><p>Update link state.</p><table class="signature" summary="@(label)"><tr><td>&lt;type name="flow" class="composite" source="list" provides="frame"&gt;
    &lt;descriptor name="amqp:flow:list" code="0x00000000:0x00000013"/&gt;
    &lt;field name="next-incoming-id" type="transfer-number"/&gt;
    &lt;field name="incoming-window" type="uint" mandatory="true"/&gt;
    &lt;field name="next-outgoing-id" type="transfer-number" mandatory="true"/&gt;
    &lt;field name="outgoing-window" type="uint" mandatory="true"/&gt;
    &lt;field name="handle" type="handle"/&gt;
    &lt;field name="delivery-count" type="sequence-no"/&gt;
    &lt;field name="link-credit" type="uint"/&gt;
    &lt;field name="available" type="uint"/&gt;
    &lt;field name="drain" type="boolean" default="false"/&gt;
    &lt;field name="echo" type="boolean" default="false"/&gt;
    &lt;field name="properties" type="fields"/&gt;
&lt;/type&gt;</td></tr></table><div class="doc"><p>Updates the flow state for the specified link.</p></div><table class="composite" summary="flow fields"><tr><td><b>next-incoming-id</b></td><td><i></i></td><td>optional <a href="#type-transfer-number">transfer-number</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            Identifies the expected transfer-id of the next incoming <a href="#type-transfer">transfer</a> frame.
            This value MUST be set if the peer has received the <a href="#type-begin">begin</a> frame for the
            session, and MUST NOT be set if it has not. See <a href="#doc-session-flow-control" title="session-flow-control">subsection 2.5.6</a> for more details.
          </p></div></td></tr><tr><td><b>incoming-window</b></td><td><i></i></td><td>mandatory <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#type-uint">uint</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            Defines the maximum number of incoming <a href="#type-transfer">transfer</a> frames that the endpoint
            can currently receive. See <a href="#doc-session-flow-control" title="session-flow-control">subsection 2.5.6</a> for more
            details.
          </p></div></td></tr><tr><td><b>next-outgoing-id</b></td><td><i></i></td><td>mandatory <a href="#type-transfer-number">transfer-number</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            The transfer-id that will be assigned to the next outgoing <a href="#type-transfer">transfer</a>
            frame. See <a href="#doc-session-flow-control" title="session-flow-control">subsection 2.5.6</a> for more details.
          </p></div></td></tr><tr><td><b>outgoing-window</b></td><td><i></i></td><td>mandatory <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#type-uint">uint</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            Defines the maximum number of outgoing <a href="#type-transfer">transfer</a> frames that the endpoint
            could potentially currently send, if it was not constrained by restrictions imposed by
            its peer's incoming-window. See <a href="#doc-session-flow-control" title="session-flow-control">subsection 2.5.6</a> for more
            details.
          </p></div></td></tr><tr><td><b>handle</b></td><td><i></i></td><td>optional <a href="#type-handle">handle</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            If set, indicates that the flow frame carries flow state information for the local link
            endpoint associated with the given handle. If not set, the flow frame is carrying only
            information pertaining to the session endpoint.
          </p><p>
            If set to a handle that is not currently associated with an attached link, the
            recipient MUST respond by ending the session with an <a href="#choice-session-error-unattached-handle">unattached-handle</a> session error.
          </p></div></td></tr><tr><td><b>delivery-count</b></td><td><i>the endpoint's value for the delivery-count sequence number</i></td><td>optional <a href="#type-sequence-no">sequence-no</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            See <a href="#doc-flow-control" title="flow-control">subsection 2.6.7</a> for the definition of delivery-count.
          </p><p>
            When the handle field is not set, this field MUST NOT be set.
          </p><p>
            When the handle identifies that the flow state is being sent from the sender link
            endpoint to receiver link endpoint this field MUST be set to the current delivery-count
            of the link endpoint.
          </p><p>
            When the flow state is being sent from the receiver endpoint to the sender endpoint this
            field MUST be set to the last known value of the corresponding sending endpoint. In the
            event that the receiving link endpoint has not yet  seen the initial
            <a href="#type-attach">attach</a> frame from the sender this field MUST NOT be set.
          </p></div></td></tr><tr><td><b>link-credit</b></td><td><i>the current maximum number of messages that can be received</i></td><td>optional <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#type-uint">uint</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            The current maximum number of messages that can be handled at the receiver
            endpoint of the link. Only the receiver endpoint can independently set this value. The
            sender endpoint sets this to the last known value seen from the receiver. See
            <a href="#doc-flow-control" title="flow-control">subsection 2.6.7</a> for more details.
          </p><p>
            When the handle field is not set, this field MUST NOT be set.
          </p></div></td></tr><tr><td><b>available</b></td><td><i>the number of available messages</i></td><td>optional <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#type-uint">uint</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            The number of messages awaiting credit at the link sender endpoint. Only the
            sender can independently set this value. The receiver sets this to the last known value
            seen from the sender. See <a href="#doc-flow-control" title="flow-control">subsection 2.6.7</a> for more details.
          </p><p>
            When the handle field is not set, this field MUST NOT be set.
          </p></div></td></tr><tr><td><b>drain</b></td><td><i>indicates drain mode</i></td><td>optional <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#type-boolean">boolean</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            When flow state is sent from the sender to the receiver, this field contains the actual
            drain mode of the sender. When flow state is sent from the receiver to the sender, this
            field contains the desired drain mode of the receiver. See <a href="#doc-flow-control" title="flow-control">subsection 2.6.7</a> for more details.
          </p><p>
            When the handle field is not set, this field MUST NOT be set.
          </p></div></td></tr><tr><td><b>echo</b></td><td><i>request state from partner</i></td><td>optional <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#type-boolean">boolean</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            If set to true then the receiver SHOULD send its state at the earliest convenient
            opportunity.
          </p><p>
            If set to true, and the handle field is not set, then the sender only requires session
            endpoint state to be echoed, however, the receiver MAY fulfil this requirement by
            sending a flow performative carrying link-specific state (since any such flow also
            carries session state).
          </p><p>
            If a sender makes multiple requests for the same state before the receiver can reply,
            the receiver MAY send only one flow in return.
          </p><p>
            Note that if a peer responds to echo requests with flows which themselves have the echo
            field set to true, an infinite loop could result if its partner adopts the same policy
            (therefore such a policy SHOULD be avoided).
          </p></div></td></tr><tr><td><b>properties</b></td><td><i>link state properties</i></td><td>optional <a href="#type-fields">fields</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            A registry of commonly defined link state properties and their meanings is maintained
            [<a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-overview-v1.0-os.html#anchor-AMQPLINKSTATEPROP">AMQPLINKSTATEPROP</a>].
          </p><p>
            When the handle field is not set, this field MUST NOT be set.
          </p></div></td></tr></table><h3><a class="toc" href="#toc">←</a>2.7.5 <a name="type-transfer">Transfer</a></h3><p>Transfer a message.</p><table class="signature" summary="@(label)"><tr><td>&lt;type name="transfer" class="composite" source="list" provides="frame"&gt;
    &lt;descriptor name="amqp:transfer:list" code="0x00000000:0x00000014"/&gt;
    &lt;field name="handle" type="handle" mandatory="true"/&gt;
    &lt;field name="delivery-id" type="delivery-number"/&gt;
    &lt;field name="delivery-tag" type="delivery-tag"/&gt;
    &lt;field name="message-format" type="message-format"/&gt;
    &lt;field name="settled" type="boolean"/&gt;
    &lt;field name="more" type="boolean" default="false"/&gt;
    &lt;field name="rcv-settle-mode" type="receiver-settle-mode"/&gt;
    &lt;field name="state" type="*" requires="delivery-state"/&gt;
    &lt;field name="resume" type="boolean" default="false"/&gt;
    &lt;field name="aborted" type="boolean" default="false"/&gt;
    &lt;field name="batchable" type="boolean" default="false"/&gt;
&lt;/type&gt;</td></tr></table><div class="doc"><p>
          The transfer frame is used to send messages across a link. Messages MAY be carried by a
          single transfer up to the maximum negotiated frame size for the connection. Larger
          messages MAY be split across several transfer frames.
        </p></div><table class="composite" summary="transfer fields"><tr><td><b>handle</b></td><td><i></i></td><td>mandatory <a href="#type-handle">handle</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>Specifies the link on which the message is transferred.</p></div></td></tr><tr><td><b>delivery-id</b></td><td><i>alias for delivery-tag</i></td><td>optional <a href="#type-delivery-number">delivery-number</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            The delivery-id MUST be supplied on the first transfer of a multi-transfer delivery. On
            continuation transfers the delivery-id MAY be omitted. It is an error if the delivery-id
            on a continuation transfer differs from the delivery-id on the first transfer of a
            delivery.
          </p></div></td></tr><tr><td><b>delivery-tag</b></td><td><i></i></td><td>optional <a href="#type-delivery-tag">delivery-tag</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            Uniquely identifies the delivery attempt for a given message on this link. This field
            MUST be specified for the first transfer of a multi-transfer message and can only be
            omitted for continuation transfers. It is an error if the delivery-tag on a continuation
            transfer differs from the delivery-tag on the first transfer of a delivery.
          </p></div></td></tr><tr><td><b>message-format</b></td><td><i>indicates the message format</i></td><td>optional <a href="#type-message-format">message-format</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            This field MUST be specified for the first transfer of a multi-transfer message and can
            only be omitted for continuation transfers. It is an error if the message-format on a
            continuation transfer differs from the message-format on the first transfer of a
            delivery.
          </p></div></td></tr><tr><td><b>settled</b></td><td><i></i></td><td>optional <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#type-boolean">boolean</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
             If not set on the first (or only) transfer for a (multi-transfer) delivery, then the
             settled flag MUST be interpreted as being false. For subsequent transfers in a
             multi-transfer delivery if the settled flag is left unset then it MUST be interpreted
             as true if and only if the value of the settled flag on any of the preceding transfers
             was true; if no preceding transfer was sent with settled being true then the value when
             unset MUST be taken as false.
          </p><p>
             If the negotiated value for snd-settle-mode at attachment is <a href="#choice-sender-settle-mode-settled">settled</a>, then this field MUST be true on at least
             one transfer frame for a delivery (i.e., the delivery MUST be settled at the sender at
             the point the delivery has been completely transferred).
          </p><p>
             If the negotiated value for snd-settle-mode at attachment is <a href="#choice-sender-settle-mode-unsettled">unsettled</a>, then this field MUST be false (or
             unset) on every transfer frame for a delivery (unless the delivery is aborted).
          </p></div></td></tr><tr><td><b>more</b></td><td><i>indicates that the message has more content</i></td><td>optional <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#type-boolean">boolean</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            Note that if both the more and aborted fields are set to true, the aborted flag takes
            precedence. That is, a receiver SHOULD ignore the value of the more field if the
            transfer is marked as aborted. A sender SHOULD NOT set the more flag to true if it
            also sets the aborted flag to true.
          </p></div></td></tr><tr><td><b>rcv-settle-mode</b></td><td><i></i></td><td>optional <a href="#type-receiver-settle-mode">receiver-settle-mode</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            If <a href="#choice-receiver-settle-mode-first">first</a>, this indicates that the
            receiver MUST settle the delivery once it has arrived without waiting for the sender to
            settle first.
          </p><p>
            If <a href="#choice-receiver-settle-mode-second">second</a>, this indicates that the
            receiver MUST NOT settle until sending its disposition to the sender and receiving a
            settled disposition from the sender.
          </p><p>
            If not set, this value is defaulted to the value negotiated on link attach.
          </p><p>
            If the negotiated link value is <a href="#choice-receiver-settle-mode-first">first</a>,
            then it is illegal to set this field to <a href="#choice-receiver-settle-mode-second">second</a>.
          </p><p>
            If the message is being sent settled by the sender, the value of this field is ignored.
          </p><p>
            The (implicit or explicit) value of this field does not form part of the transfer state,
            and is not retained if a link is suspended and subsequently resumed.
          </p></div></td></tr><tr><td><b>state</b></td><td><i>the state of the delivery at the sender</i></td><td>optional *</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            When set this informs the receiver of the state of the delivery at the sender. This is
            particularly useful when transfers of unsettled deliveries are resumed after resuming a
            link. Setting the state on the transfer can be thought of as being equivalent to sending
            a disposition immediately before the <a href="#type-transfer">transfer</a> performative, i.e., it is
            the state of the delivery (not the transfer) that existed at the point the frame was
            sent.
          </p><p>
            Note that if the <a href="#type-transfer">transfer</a> performative (or an earlier <a href="#type-disposition">disposition</a> performative referring to the delivery) indicates that the delivery
            has attained a terminal state, then no future <a href="#type-transfer">transfer</a> or <a href="#type-disposition">disposition</a> sent by the sender can alter that terminal state.
          </p></div></td></tr><tr><td><b>resume</b></td><td><i>indicates a resumed delivery</i></td><td>optional <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#type-boolean">boolean</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            If true, the resume flag indicates that the transfer is being used to reassociate an
            unsettled delivery from a dissociated link endpoint. See
            <a href="#doc-resuming-deliveries" title="resuming-deliveries">subsection 2.6.13</a> for more details.
          </p><p>
            The receiver MUST ignore resumed deliveries that are not in its local unsettled map. The
            sender MUST NOT send resumed transfers for deliveries not in its local unsettled map.
          </p><p>
            If a resumed delivery spans more than one transfer performative, then the resume flag
            MUST be set to true on the first transfer of the resumed delivery. For subsequent
            transfers for the same delivery the resume flag MAY be set to true, or MAY be omitted.
          </p><p>
            In the case where the exchange of unsettled maps makes clear that all message data has
            been successfully transferred to the receiver, and that only the final state (and
            potentially settlement) at the sender needs to be conveyed, then a resumed delivery MAY
            carry no payload and instead act solely as a vehicle for carrying the terminal state of
            the delivery at the sender.
           </p></div></td></tr><tr><td><b>aborted</b></td><td><i>indicates that the message is aborted</i></td><td>optional <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#type-boolean">boolean</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            Aborted messages SHOULD be discarded by the recipient (any payload within the frame
            carrying the performative MUST be ignored). An aborted message is implicitly settled.
          </p></div></td></tr><tr><td><b>batchable</b></td><td><i>batchable hint</i></td><td>optional <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#type-boolean">boolean</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            If true, then the issuer is hinting that there is no need for the peer to urgently
            communicate updated delivery state. This hint MAY be used to artificially increase the
            amount of batching an implementation uses when communicating delivery states, and
            thereby save bandwidth.
          </p><p>
            If the message being delivered is too large to fit within a single frame, then the
            setting of batchable to true on any of the <a href="#type-transfer">transfer</a> performatives for the
            delivery is equivalent to setting batchable to true for all the <a href="#type-transfer">transfer</a>
            performatives for the delivery.
          </p><p>
            The batchable value does not form part of the transfer state, and is not retained if
            a link is suspended and subsequently resumed.
          </p></div></td></tr></table><h3><a class="toc" href="#toc">←</a>2.7.6 <a name="type-disposition">Disposition</a></h3><p>Inform remote peer of delivery state changes.</p><table class="signature" summary="@(label)"><tr><td>&lt;type name="disposition" class="composite" source="list" provides="frame"&gt;
    &lt;descriptor name="amqp:disposition:list" code="0x00000000:0x00000015"/&gt;
    &lt;field name="role" type="role" mandatory="true"/&gt;
    &lt;field name="first" type="delivery-number" mandatory="true"/&gt;
    &lt;field name="last" type="delivery-number"/&gt;
    &lt;field name="settled" type="boolean" default="false"/&gt;
    &lt;field name="state" type="*" requires="delivery-state"/&gt;
    &lt;field name="batchable" type="boolean" default="false"/&gt;
&lt;/type&gt;</td></tr></table><div class="doc"><p>
          The disposition frame is used to inform the remote peer of local changes in the state of
          deliveries. The disposition frame MAY reference deliveries from many different links
          associated with a session, although all links MUST have the directionality indicated by
          the specified <i>role</i>.
        </p><p>
          Note that it is possible for a disposition sent from sender to receiver to refer to a
          delivery which has not yet completed (i.e., a delivery which is spread over multiple
          frames and not all frames have yet been sent). The use of such interleaving is
          discouraged in favor of carrying the modified state on the next <a href="#type-transfer">transfer</a>
          performative for the delivery.
        </p><p>
          The disposition performative MAY refer to deliveries on links that are no longer attached.
          As long as the links have not been closed or detached with an error then the deliveries
          are still "live" and the updated state MUST be applied.
        </p></div><table class="composite" summary="disposition fields"><tr><td><b>role</b></td><td><i>directionality of disposition</i></td><td>mandatory <a href="#type-role">role</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            The role identifies whether the disposition frame contains information
            about <i>sending</i> link endpoints or <i>receiving</i> link endpoints.
          </p></div></td></tr><tr><td><b>first</b></td><td><i>lower bound of deliveries</i></td><td>mandatory <a href="#type-delivery-number">delivery-number</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            Identifies the lower bound of delivery-ids for the deliveries in this set.
          </p></div></td></tr><tr><td><b>last</b></td><td><i>upper bound of deliveries</i></td><td>optional <a href="#type-delivery-number">delivery-number</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            Identifies the upper bound of delivery-ids for the deliveries in this set. If not set,
            this is taken to be the same as <i>first</i>.
          </p></div></td></tr><tr><td><b>settled</b></td><td><i>indicates deliveries are settled</i></td><td>optional <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#type-boolean">boolean</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            If true, indicates that the referenced deliveries are considered settled by the issuing
            endpoint.
          </p></div></td></tr><tr><td><b>state</b></td><td><i>indicates state of deliveries</i></td><td>optional *</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            Communicates the state of all the deliveries referenced by this disposition.
          </p></div></td></tr><tr><td><b>batchable</b></td><td><i>batchable hint</i></td><td>optional <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#type-boolean">boolean</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            If true, then the issuer is hinting that there is no need for the peer to urgently
            communicate the impact of the updated delivery states. This hint MAY be used to
            artificially increase the amount of batching an implementation uses when communicating
            delivery states, and thereby save bandwidth.
          </p></div></td></tr></table><h3><a class="toc" href="#toc">←</a>2.7.7 <a name="type-detach">Detach</a></h3><p>Detach the link endpoint from the session.</p><table class="signature" summary="@(label)"><tr><td>&lt;type name="detach" class="composite" source="list" provides="frame"&gt;
    &lt;descriptor name="amqp:detach:list" code="0x00000000:0x00000016"/&gt;
    &lt;field name="handle" type="handle" mandatory="true"/&gt;
    &lt;field name="closed" type="boolean" default="false"/&gt;
    &lt;field name="error" type="error"/&gt;
&lt;/type&gt;</td></tr></table><div class="doc"><p>
          Detach the link endpoint from the session. This unmaps the handle and makes it available
          for use by other links.
        </p></div><table class="composite" summary="detach fields"><tr><td><b>handle</b></td><td><i>the local handle of the link to be detached</i></td><td>mandatory <a href="#type-handle">handle</a></td></tr><tr><td class="field" colspan="2"></td></tr><tr><td><b>closed</b></td><td><i>if true then the sender has closed the link</i></td><td>optional <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#type-boolean">boolean</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>See <a href="#doc-closing-a-link" title="closing-a-link">subsection 2.6.6</a>.</p></div></td></tr><tr><td><b>error</b></td><td><i>error causing the detach</i></td><td>optional <a href="#type-error">error</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            If set, this field indicates that the link is being detached due to an error condition.
            The value of the field SHOULD contain details on the cause of the error.
          </p></div></td></tr></table><h3><a class="toc" href="#toc">←</a>2.7.8 <a name="type-end">End</a></h3><p>End the session.</p><table class="signature" summary="@(label)"><tr><td>&lt;type name="end" class="composite" source="list" provides="frame"&gt;
    &lt;descriptor name="amqp:end:list" code="0x00000000:0x00000017"/&gt;
    &lt;field name="error" type="error"/&gt;
&lt;/type&gt;</td></tr></table><div class="doc"><p>Indicates that the session has ended.</p></div><table class="composite" summary="end fields"><tr><td><b>error</b></td><td><i>error causing the end</i></td><td>optional <a href="#type-error">error</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            If set, this field indicates that the session is being ended due to an error condition.
            The value of the field SHOULD contain details on the cause of the error.
          </p></div></td></tr></table><h3><a class="toc" href="#toc">←</a>2.7.9 <a name="type-close">Close</a></h3><p>Signal a connection close.</p><table class="signature" summary="@(label)"><tr><td>&lt;type name="close" class="composite" source="list" provides="frame"&gt;
    &lt;descriptor name="amqp:close:list" code="0x00000000:0x00000018"/&gt;
    &lt;field name="error" type="error"/&gt;
&lt;/type&gt;</td></tr></table><div class="doc"><p>
          Sending a close signals that the sender will not be sending any more frames (or bytes of
          any other kind) on the connection. Orderly shutdown requires that this frame MUST be
          written by the sender. It is illegal to send any more frames (or bytes of any other kind)
          after sending a close frame.
        </p></div><table class="composite" summary="close fields"><tr><td><b>error</b></td><td><i>error causing the close</i></td><td>optional <a href="#type-error">error</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            If set, this field indicates that the connection is being closed due to an error
            condition. The value of the field SHOULD contain details on the cause of the error.
          </p></div></td></tr></table></div>

  <h2><a class="toc" href="#toc">←</a>2.8 <a name="section-definitions">Definitions</a></h2><div class="section"><h3><a class="toc" href="#toc">←</a>2.8.1 <a name="type-role">Role</a></h3><p>Link endpoint role.</p><table class="signature" summary="@(label)"><tr><td>&lt;type name="role" class="restricted" source="boolean"&gt;
    &lt;choice name="sender" value="false"/&gt;
    &lt;choice name="receiver" value="true"/&gt;
&lt;/type&gt;</td></tr></table><table class="composite" summary="possible values"><tr><td><b><a class="anchor" name="choice-role-sender">sender</a></b></td><td></td><td>false</td></tr><tr><td class="field" colspan="2"></td></tr><tr><td><b><a class="anchor" name="choice-role-receiver">receiver</a></b></td><td></td><td>true</td></tr><tr><td class="field" colspan="2"></td></tr></table><h3><a class="toc" href="#toc">←</a>2.8.2 <a name="type-sender-settle-mode">Sender Settle Mode</a></h3><p>Settlement policy for a sender.</p><table class="signature" summary="@(label)"><tr><td>&lt;type name="sender-settle-mode" class="restricted" source="ubyte"&gt;
    &lt;choice name="unsettled" value="0"/&gt;
    &lt;choice name="settled" value="1"/&gt;
    &lt;choice name="mixed" value="2"/&gt;
&lt;/type&gt;</td></tr></table><table class="composite" summary="possible values"><tr><td><b><a class="anchor" name="choice-sender-settle-mode-unsettled">unsettled</a></b></td><td></td><td>0</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            The sender will send all deliveries initially unsettled to the receiver.
          </p></div></td></tr><tr><td><b><a class="anchor" name="choice-sender-settle-mode-settled">settled</a></b></td><td></td><td>1</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            The sender will send all deliveries settled to the receiver.
          </p></div></td></tr><tr><td><b><a class="anchor" name="choice-sender-settle-mode-mixed">mixed</a></b></td><td></td><td>2</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            The sender MAY send a mixture of settled and unsettled deliveries to the receiver.
          </p></div></td></tr></table><h3><a class="toc" href="#toc">←</a>2.8.3 <a name="type-receiver-settle-mode">Receiver Settle Mode</a></h3><p>Settlement policy for a receiver.</p><table class="signature" summary="@(label)"><tr><td>&lt;type name="receiver-settle-mode" class="restricted" source="ubyte"&gt;
    &lt;choice name="first" value="0"/&gt;
    &lt;choice name="second" value="1"/&gt;
&lt;/type&gt;</td></tr></table><table class="composite" summary="possible values"><tr><td><b><a class="anchor" name="choice-receiver-settle-mode-first">first</a></b></td><td></td><td>0</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            The receiver will spontaneously settle all incoming transfers.
          </p></div></td></tr><tr><td><b><a class="anchor" name="choice-receiver-settle-mode-second">second</a></b></td><td></td><td>1</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            The receiver will only settle after sending the <a href="#type-disposition">disposition</a> to the sender
            and receiving a <a href="#type-disposition">disposition</a> indicating settlement of the delivery from
            the sender.
          </p></div></td></tr></table><h3><a class="toc" href="#toc">←</a>2.8.4 <a name="type-handle">Handle</a></h3><p>The handle of a link.</p><table class="signature" summary="@(label)"><tr><td>&lt;type name="handle" class="restricted" source="uint"/&gt;</td></tr></table><div class="doc"><p>
          An alias established by the <a href="#type-attach">attach</a> frame and subsequently used
          by endpoints as a shorthand to refer to the link in all outgoing frames. The two endpoints
          MAY potentially use different handles to refer to the same link. Link handles MAY be
          reused once a link is closed for both send and receive.
        </p></div><table class="composite" summary="possible values"></table><h3><a class="toc" href="#toc">←</a>2.8.5 <a name="type-seconds">Seconds</a></h3><p>A duration measured in seconds.</p><table class="signature" summary="@(label)"><tr><td>&lt;type name="seconds" class="restricted" source="uint"/&gt;</td></tr></table><table class="composite" summary="possible values"></table><h3><a class="toc" href="#toc">←</a>2.8.6 <a name="type-milliseconds">Milliseconds</a></h3><p>A duration measured in milliseconds.</p><table class="signature" summary="@(label)"><tr><td>&lt;type name="milliseconds" class="restricted" source="uint"/&gt;</td></tr></table><table class="composite" summary="possible values"></table><h3><a class="toc" href="#toc">←</a>2.8.7 <a name="type-delivery-tag">Delivery Tag</a></h3><table class="signature" summary="@(label)"><tr><td>&lt;type name="delivery-tag" class="restricted" source="binary"/&gt;</td></tr></table><div class="doc"><p>
           A delivery-tag can be up to 32 octets of binary data.
         </p></div><table class="composite" summary="possible values"></table><h3><a class="toc" href="#toc">←</a>2.8.8 <a name="type-delivery-number">Delivery Number</a></h3><table class="signature" summary="@(label)"><tr><td>&lt;type name="delivery-number" class="restricted" source="sequence-no"/&gt;</td></tr></table><table class="composite" summary="possible values"></table><h3><a class="toc" href="#toc">←</a>2.8.9 <a name="type-transfer-number">Transfer Number</a></h3><table class="signature" summary="@(label)"><tr><td>&lt;type name="transfer-number" class="restricted" source="sequence-no"/&gt;</td></tr></table><table class="composite" summary="possible values"></table><h3><a class="toc" href="#toc">←</a>2.8.10 <a name="type-sequence-no">Sequence No</a></h3><p>32-bit RFC-1982 serial number.</p><table class="signature" summary="@(label)"><tr><td>&lt;type name="sequence-no" class="restricted" source="uint"/&gt;</td></tr></table><div class="doc"><p>
          A sequence-no encodes a serial number as defined in RFC-1982
          [<a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-overview-v1.0-os.html#anchor-RFC1982">RFC1982</a>].
          The arithmetic and operators for these numbers are defined by RFC-1982.
        </p></div><table class="composite" summary="possible values"></table><h3><a class="toc" href="#toc">←</a>2.8.11 <a name="type-message-format">Message Format</a></h3><p>32-bit message format code.</p><table class="signature" summary="@(label)"><tr><td>&lt;type name="message-format" class="restricted" source="uint"/&gt;</td></tr></table><div class="doc"><p>
          The upper three octets of a message format code identify a particular message format. The
          lowest octet indicates the version of said message format. Any given version of a format
          is forwards compatible with all higher versions.
        </p><table class="pre" summary="Layout of Message Format Code"><caption style="caption-side:bottom">Figure 2.59: Layout of Message Format Code</caption><tr><td>
      3 octets      1 octet
 +----------------+---------+
 | message format | version |
 +----------------+---------+
 |                          |
msb                        lsb
      </td></tr></table></div><table class="composite" summary="possible values"></table><h3><a class="toc" href="#toc">←</a>2.8.12 <a name="type-ietf-language-tag">Ietf Language Tag</a></h3><p>An IETF language tag as defined by BCP 47.</p><table class="signature" summary="@(label)"><tr><td>&lt;type name="ietf-language-tag" class="restricted" source="symbol"/&gt;</td></tr></table><div class="doc"><p>
          IETF language tags are abbreviated language codes as defined in the IETF Best Current
          Practice BCP-47 [<a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-overview-v1.0-os.html#anchor-BCP47">BCP47</a>]
          (incorporating IETF RFC-5646 [<a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-overview-v1.0-os.html#anchor-RFC5646">RFC5646</a>]).
          A list of registered subtags is maintained in the IANA Language Subtag Registry
          [<a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-overview-v1.0-os.html#anchor-IANASUBTAG">IANASUBTAG</a>].
        </p><p>
          All AMQP implementations SHOULD understand at the least the IETF language tag
          <i>en-US</i> (note that this uses a hyphen separator, not an underscore).
        </p></div><table class="composite" summary="possible values"></table><h3><a class="toc" href="#toc">←</a>2.8.13 <a name="type-fields">Fields</a></h3><p>A mapping from field name to value.</p><table class="signature" summary="@(label)"><tr><td>&lt;type name="fields" class="restricted" source="map"/&gt;</td></tr></table><div class="doc"><p>
          The <i>fields</i> type is a map where the keys are restricted to be of type <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#type-symbol">symbol</a> (this excludes the possibility of a null key). There is no further
          restriction implied by the <i>fields</i> type on the allowed values for the entries or the
          set of allowed keys.
        </p></div><table class="composite" summary="possible values"></table><h3><a class="toc" href="#toc">←</a>2.8.14 <a name="type-error">Error</a></h3><p>Details of an error.</p><table class="signature" summary="@(label)"><tr><td>&lt;type name="error" class="composite" source="list"&gt;
    &lt;descriptor name="amqp:error:list" code="0x00000000:0x0000001d"/&gt;
    &lt;field name="condition" type="symbol" requires="error-condition" mandatory="true"/&gt;
    &lt;field name="description" type="string"/&gt;
    &lt;field name="info" type="fields"/&gt;
&lt;/type&gt;</td></tr></table><table class="composite" summary="error fields"><tr><td><b>condition</b></td><td><i>error condition</i></td><td>mandatory <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#type-symbol">symbol</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>A symbolic value indicating the error condition.</p></div></td></tr><tr><td><b>description</b></td><td><i>descriptive text about the error condition</i></td><td>optional <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#type-string">string</a></td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            This text supplies any supplementary details not indicated by the condition field. This
            text can be logged as an aid to resolving issues.
          </p></div></td></tr><tr><td><b>info</b></td><td><i>map carrying information about the error condition</i></td><td>optional <a href="#type-fields">fields</a></td></tr><tr><td class="field" colspan="2"></td></tr></table><h3><a class="toc" href="#toc">←</a>2.8.15 <a name="type-amqp-error">Amqp Error</a></h3><p>Shared error conditions.</p><table class="signature" summary="@(label)"><tr><td>&lt;type name="amqp-error" class="restricted" source="symbol" provides="error-condition"&gt;
    &lt;choice name="internal-error" value="amqp:internal-error"/&gt;
    &lt;choice name="not-found" value="amqp:not-found"/&gt;
    &lt;choice name="unauthorized-access" value="amqp:unauthorized-access"/&gt;
    &lt;choice name="decode-error" value="amqp:decode-error"/&gt;
    &lt;choice name="resource-limit-exceeded" value="amqp:resource-limit-exceeded"/&gt;
    &lt;choice name="not-allowed" value="amqp:not-allowed"/&gt;
    &lt;choice name="invalid-field" value="amqp:invalid-field"/&gt;
    &lt;choice name="not-implemented" value="amqp:not-implemented"/&gt;
    &lt;choice name="resource-locked" value="amqp:resource-locked"/&gt;
    &lt;choice name="precondition-failed" value="amqp:precondition-failed"/&gt;
    &lt;choice name="resource-deleted" value="amqp:resource-deleted"/&gt;
    &lt;choice name="illegal-state" value="amqp:illegal-state"/&gt;
    &lt;choice name="frame-size-too-small" value="amqp:frame-size-too-small"/&gt;
&lt;/type&gt;</td></tr></table><table class="composite" summary="possible values"><tr><td><b><a class="anchor" name="choice-amqp-error-internal-error">internal-error</a></b></td><td></td><td>amqp:internal-error</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            An internal error occurred. Operator intervention might be necessary to resume normal
            operation.
          </p></div></td></tr><tr><td><b><a class="anchor" name="choice-amqp-error-not-found">not-found</a></b></td><td></td><td>amqp:not-found</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>A peer attempted to work with a remote entity that does not exist.</p></div></td></tr><tr><td><b><a class="anchor" name="choice-amqp-error-unauthorized-access">unauthorized-access</a></b></td><td></td><td>amqp:unauthorized-access</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            A peer attempted to work with a remote entity to which it has no access due to security
            settings.
          </p></div></td></tr><tr><td><b><a class="anchor" name="choice-amqp-error-decode-error">decode-error</a></b></td><td></td><td>amqp:decode-error</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>Data could not be decoded.</p></div></td></tr><tr><td><b><a class="anchor" name="choice-amqp-error-resource-limit-exceeded">resource-limit-exceeded</a></b></td><td></td><td>amqp:resource-limit-exceeded</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>A peer exceeded its resource allocation.</p></div></td></tr><tr><td><b><a class="anchor" name="choice-amqp-error-not-allowed">not-allowed</a></b></td><td></td><td>amqp:not-allowed</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            The peer tried to use a frame in a manner that is inconsistent with the semantics
            defined in the specification.
          </p></div></td></tr><tr><td><b><a class="anchor" name="choice-amqp-error-invalid-field">invalid-field</a></b></td><td></td><td>amqp:invalid-field</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            An invalid field was passed in a frame body, and the operation could not proceed.
          </p></div></td></tr><tr><td><b><a class="anchor" name="choice-amqp-error-not-implemented">not-implemented</a></b></td><td></td><td>amqp:not-implemented</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>The peer tried to use functionality that is not implemented in its partner.</p></div></td></tr><tr><td><b><a class="anchor" name="choice-amqp-error-resource-locked">resource-locked</a></b></td><td></td><td>amqp:resource-locked</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            The client attempted to work with a server entity to which it has no access because
            another client is working with it.
          </p></div></td></tr><tr><td><b><a class="anchor" name="choice-amqp-error-precondition-failed">precondition-failed</a></b></td><td></td><td>amqp:precondition-failed</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            The client made a request that was not allowed because some precondition failed.
          </p></div></td></tr><tr><td><b><a class="anchor" name="choice-amqp-error-resource-deleted">resource-deleted</a></b></td><td></td><td>amqp:resource-deleted</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>A server entity the client is working with has been deleted.</p></div></td></tr><tr><td><b><a class="anchor" name="choice-amqp-error-illegal-state">illegal-state</a></b></td><td></td><td>amqp:illegal-state</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            The peer sent a frame that is not permitted in the current state.
          </p></div></td></tr><tr><td><b><a class="anchor" name="choice-amqp-error-frame-size-too-small">frame-size-too-small</a></b></td><td></td><td>amqp:frame-size-too-small</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            The peer cannot send a frame because the smallest encoding of the performative with the
            currently valid values would be too large to fit within a frame of the agreed maximum
            frame size. When transferring a message the message data can be sent in multiple <a href="#type-transfer">transfer</a> frames thereby avoiding this error. Similarly when attaching a link
            with a large unsettled map the endpoint MAY make use of the incomplete-unsettled flag to
            avoid the need for overly large frames.
          </p></div></td></tr></table><h3><a class="toc" href="#toc">←</a>2.8.16 <a name="type-connection-error">Connection Error</a></h3><p>Symbols used to indicate connection error conditions.</p><table class="signature" summary="@(label)"><tr><td>&lt;type name="connection-error" class="restricted" source="symbol" provides="error-condition"&gt;
    &lt;choice name="connection-forced" value="amqp:connection:forced"/&gt;
    &lt;choice name="framing-error" value="amqp:connection:framing-error"/&gt;
    &lt;choice name="redirect" value="amqp:connection:redirect"/&gt;
&lt;/type&gt;</td></tr></table><table class="composite" summary="possible values"><tr><td><b><a class="anchor" name="choice-connection-error-connection-forced">connection-forced</a></b></td><td></td><td>amqp:connection:forced</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            An operator intervened to close the connection for some reason. The client could retry
            at some later date.
          </p></div></td></tr><tr><td><b><a class="anchor" name="choice-connection-error-framing-error">framing-error</a></b></td><td></td><td>amqp:connection:framing-error</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>A valid frame header cannot be formed from the incoming byte stream.</p></div></td></tr><tr><td><b><a class="anchor" name="choice-connection-error-redirect">redirect</a></b></td><td></td><td>amqp:connection:redirect</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            The container is no longer available on the current connection. The peer SHOULD
            attempt reconnection to the container using the details provided in the info map.
          </p><dl>
            <dt>hostname</dt>
            <dd>
              <p>
                 the hostname of the container. This is the value that SHOULD be supplied in the
                 <i>hostname</i> field of the <a href="#type-open">open</a> frame, and during the SASL and
                 TLS negotiation (if used).
              </p>
            </dd>
            <dt>network-host</dt>
            <dd>
              <p>
                the DNS hostname or IP address of the machine hosting the container.
              </p>
            </dd>
            <dt>port</dt>
            <dd>
              <p>
                the port number on the machine hosting the container.
              </p>
            </dd>
          </dl></div></td></tr></table><h3><a class="toc" href="#toc">←</a>2.8.17 <a name="type-session-error">Session Error</a></h3><p>Symbols used to indicate session error conditions.</p><table class="signature" summary="@(label)"><tr><td>&lt;type name="session-error" class="restricted" source="symbol" provides="error-condition"&gt;
    &lt;choice name="window-violation" value="amqp:session:window-violation"/&gt;
    &lt;choice name="errant-link" value="amqp:session:errant-link"/&gt;
    &lt;choice name="handle-in-use" value="amqp:session:handle-in-use"/&gt;
    &lt;choice name="unattached-handle" value="amqp:session:unattached-handle"/&gt;
&lt;/type&gt;</td></tr></table><table class="composite" summary="possible values"><tr><td><b><a class="anchor" name="choice-session-error-window-violation">window-violation</a></b></td><td></td><td>amqp:session:window-violation</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            The peer violated incoming window for the session.
          </p></div></td></tr><tr><td><b><a class="anchor" name="choice-session-error-errant-link">errant-link</a></b></td><td></td><td>amqp:session:errant-link</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            Input was received for a link that was detached with an error.
          </p></div></td></tr><tr><td><b><a class="anchor" name="choice-session-error-handle-in-use">handle-in-use</a></b></td><td></td><td>amqp:session:handle-in-use</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            An attach was received using a handle that is already in use for an attached link.
          </p></div></td></tr><tr><td><b><a class="anchor" name="choice-session-error-unattached-handle">unattached-handle</a></b></td><td></td><td>amqp:session:unattached-handle</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            A frame (other than attach) was received referencing a handle which is not currently
            in use of an attached link.
          </p></div></td></tr></table><h3><a class="toc" href="#toc">←</a>2.8.18 <a name="type-link-error">Link Error</a></h3><p>Symbols used to indicate link error conditions.</p><table class="signature" summary="@(label)"><tr><td>&lt;type name="link-error" class="restricted" source="symbol" provides="error-condition"&gt;
    &lt;choice name="detach-forced" value="amqp:link:detach-forced"/&gt;
    &lt;choice name="transfer-limit-exceeded" value="amqp:link:transfer-limit-exceeded"/&gt;
    &lt;choice name="message-size-exceeded" value="amqp:link:message-size-exceeded"/&gt;
    &lt;choice name="redirect" value="amqp:link:redirect"/&gt;
    &lt;choice name="stolen" value="amqp:link:stolen"/&gt;
&lt;/type&gt;</td></tr></table><table class="composite" summary="possible values"><tr><td><b><a class="anchor" name="choice-link-error-detach-forced">detach-forced</a></b></td><td></td><td>amqp:link:detach-forced</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            An operator intervened to detach for some reason.
          </p></div></td></tr><tr><td><b><a class="anchor" name="choice-link-error-transfer-limit-exceeded">transfer-limit-exceeded</a></b></td><td></td><td>amqp:link:transfer-limit-exceeded</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>The peer sent more message transfers than currently allowed on the link.</p></div></td></tr><tr><td><b><a class="anchor" name="choice-link-error-message-size-exceeded">message-size-exceeded</a></b></td><td></td><td>amqp:link:message-size-exceeded</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>The peer sent a larger message than is supported on the link.</p></div></td></tr><tr><td><b><a class="anchor" name="choice-link-error-redirect">redirect</a></b></td><td></td><td>amqp:link:redirect</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>The address provided cannot be resolved to a terminus at the current container.
             The info map MAY contain the following information to allow the client to locate
             the attach to the terminus.
          </p><dl>
            <dt>hostname</dt>
            <dd>
              <p>
                 the hostname of the container hosting the terminus. This is the value that SHOULD
                 be supplied in the <i>hostname</i> field of the <a href="#type-open">open</a> frame, and
                 during SASL and TLS negotiation (if used).
              </p>
            </dd>
            <dt>network-host</dt>
            <dd>
              <p>
                the DNS hostname or IP address of the machine hosting the container.
              </p>
            </dd>
            <dt>port</dt>
            <dd>
              <p>
                the port number on the machine hosting the container.
              </p>
            </dd>
            <dt>address</dt>
            <dd>
              <p>
                the address of the terminus at the container.
              </p>
            </dd>
          </dl></div></td></tr><tr><td><b><a class="anchor" name="choice-link-error-stolen">stolen</a></b></td><td></td><td>amqp:link:stolen</td></tr><tr><td class="field" colspan="2"><div class="doc"><p>
            The link has been attached elsewhere, causing the existing attachment to be forcibly
            closed.
          </p></div></td></tr></table><h3><a class="toc" href="#toc">←</a>2.8.19 <a name="definition-idp861488">Constant Definitions</a></h3><table class="constants"><tr><td><a name="definition-PORT">PORT</a></td><td>5672</td><td>the IANA assigned port number for AMQP. </td></tr><tr><td colspan="2"></td><td><div class="doc"><p>
          The standard AMQP port number that has been assigned by IANA for TCP, UDP, and SCTP.
        </p></div><div class="doc"><p>
          There are currently no UDP or SCTP mappings defined for AMQP. The port number is reserved
          for future transport mappings to these protocols.
        </p></div></td></tr><tr><td><a name="definition-SECURE-PORT">SECURE-PORT</a></td><td>5671</td><td>the IANA assigned port number         for secure AMQP (amqps). </td></tr><tr><td colspan="2"></td><td><div class="doc"><p>
          The standard AMQP port number that has been assigned by IANA for secure TCP using TLS.
        </p></div><div class="doc"><p>
          Implementations listening on this port SHOULD NOT expect a protocol handshake before TLS
          is negotiated.
        </p></div></td></tr><tr><td><a name="definition-MAJOR">MAJOR</a></td><td>1</td><td>major protocol version. </td></tr><tr><td><a name="definition-MINOR">MINOR</a></td><td>0</td><td>minor protocol version. </td></tr><tr><td><a name="definition-REVISION">REVISION</a></td><td>0</td><td>protocol revision. </td></tr><tr><td><a name="definition-MIN-MAX-FRAME-SIZE">MIN-MAX-FRAME-SIZE</a></td><td>512</td><td>the lower bound for the agreed maximum frame size (in bytes). </td></tr><tr><td colspan="2"></td><td><div class="doc"><p>
          During the initial connection negotiation, the two peers MUST agree upon a maximum frame
          size. This constant defines the minimum value to which the maximum frame size can be set.
          By defining this value, the peers can guarantee that they can send frames of up to this
          size until they have agreed a definitive maximum frame size for that
          connection.
        </p></div></td></tr></table></div>

<hr><table width="100%" class="partNav" border="0"><tr><td width="50%" align="left"><a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-types-v1.0-os.html#toc">&lt;&lt; Part 1: Types</a></td><td width="50%" align="right"><a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#toc">
          Part 3: Messaging &gt;&gt;
        </a></td></tr></table></body></html>
